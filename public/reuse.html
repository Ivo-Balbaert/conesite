<html>
<head>
	<meta content="text/html; charset=UTF-8" http-equiv="content-type">
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<link rel="stylesheet" type="text/css" href="standard.css" />
<title>Cone - Flexible Typing & Code Reuse</title>
</head>
<body>
	<div id="header">
		<div class="column">
		<a href="/">
			<img src="pegicon.png" width="56" height="56" alt="logo">
		</a>
		</div>
		<span id="title">Cone</span>
		<span id="sub">Flexible Typing & Code Reuse</span></div>
		<div class="column flow-opposite">
	</div>

	<div class="text">
	<p>Despite the significant performance and safety benefits of static typing, there are downsides. 
		The intentional rigidity of static types can mean that general-purpose algorithms
		(e.g., sort or hashed collections) have to be replicated
		and customized by hand for each type the algorithms are applied to,
		adversely impacting programmer productivity and code size.
		Type inflexibility also makes it harder to support heterogeneous collections,
		where each value in the collection could have a different type.</p>
	<p>To support greater code flexibility and reuse, while still enforcing type safety,
		Cone offers various techniques to improve type flexibility and help generalize algorithmic logic
		across diverse types and conditions.</p>

	<p><b>Method Overloading</b></p>
	<p>Multiple methods in a type can be given the same name but different type signatures and implementations.
		When a method of a certain name is used, the most appropriate implementation
		is automatically picked and dispatched based on the types
		of the passed arguments and the get/set context.</p>
		
	<p><b>Interfaces and Traits</b></p>
	<p>When multiple types offer methods with the same names and signatures,
		an interface type may be defined declaring this common subset of methods.
		Any object whose type complies with the interface can be coerced to an interface type reference.
		By collapsing the logic for multiple types through common interface dispatch, 
		less code is needed for each distinct type.</p>
	<p>Traits work similarly to interfaces, but add support for code and property inheritance
		for types that explicitly implement them.
		A type can mix in methods and properties from multiple traits.
		This further improves code reuse over interfaces.
	</p>

	<p><b>Fluid Permissions and Borrowed References</b></p>
	<p>To improve safety, every reference must specify its permission type.
		Similarly, to support multiple memory management strategies, every reference also
		specifies its allocator type.
		If separate logic were needed for every combination of permission and allocator types, this could get messy.</p>
	    <p>Fortunately, static permissions allow a reference
		to be safely treated as if it had a lesser permission. 
		For example, <span class="pre">const</span> is the popular default permission for a method's reference parameter,
		because it is a valid substitute for most static permissions
		(when we know a method or function won't change the value).</p>
	<p>Similarly, any reference may be coerced to a borrowed reference, regardless of which allocator manages it.
		Designing logic around the preferred use of borrowed const references,
		wherever lifetime and mutability constraints allow,
		helps significantly reduce the complexity of type libraries and program functions.</p>
	
	<p><b>Variant types</b></p>
	<p>Variant types are useful when a value might be one of several, seemingly-unrelated types 
	(but we won't know which until run-time).
	Variant types are useful for optional values (and nullable references), returned result/error, and many other uses.
	The type flexibility of dynamic languages, including their support for heterogeneous collections,
	is based on the use of variant types.
	Downcasting an interface reference to its original tagged struct requires the use of variant types.</p>
	<p>Information about the value's current type is carried as a part of the value.
	Pattern matching is used to safely extract a properly typed value for appropriate manipulation.</p>
	<p>Similar to interfaces, variant types can help reduce redundant logic.
		Variant types are more flexible in some ways than interfaces, 
		since the types contained within a variant type need not share common methods.
	   However, variant types do bear some added memory and performance costs.</p>
	
	<p><b>Generics</b></p>
	<p>Generics enable the creation of type or function logic that works across a range
		of compliant types. A type's compliance is measured similarly to a type's conformance to an interface or trait,
		but is not restricted to just references.
		Collection types are well served by this approach, as a single generic
		can encapsulate the same algorithmic logic across all the types the collection stores or indexes with.</p>
	<p>Depending on the nature of the generic's parametric types, the instantiation of a generic can vary.
		Sometimes, instantiation is a compile-time mechanism, using a macro-like mechanism to generate multiple versions
		for each type. Other times, the generic is transformed into a runtime mechanism similarly to interfaces,
		where a single piece of runtime logic can use runtime type information to generalize
	    the logic successfully across values from many different types.</p>
	</p>

	<p><b>Metaprogramming</b></p>
	<p>Metaprogramming involves the use of a scripting language "on top" of the programming language.
		This scripting language, whose syntax looks nearly identical to Cone, provides programmatic control over the
		program's compilation, offering such features as:
	</p>
	<ul>
		<li>Compile-time execution, enabling conditional logic and calculation of values at compile-time</li>
		<li>Reflection for accessing to compiler information (esp. types) to compile-time execution</li>
		<li>Macros that expand code every time they are used</li>
	</ul>
	<p>Metaprogramming is valuable for customizing, replicating or calculating logic or data at compile-time.
	The downsides of metaprogramming are: the increased complexity of writing generalizable code,
	slower compilation times, and generated-code size increases due to code expansion.</p> 
	
	</div>

</body>
</html>
