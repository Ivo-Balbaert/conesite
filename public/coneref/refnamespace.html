<html>
  <head>
	  <title>Namespaces - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Names and Namespaces</div>
		</div>

    <div class="text">
	
		<p>Variables, functions, types, etc. are usually given names when declared or defined.
			These names are always defined within a specific lexical context's namespace.</p>

		<p>Cone supports several kinds of namespaces:
			<ul>
					<li><a href="refblock.html">Blocks</a>. As we have already seen,
						code blocks support the definition of <i>local</i> named variables and functions.</li>
					<li><a href="reffunc.html#parms">Function parameters</a>. A function signature defines its named parameters,
						later usable within the function's block(s) as local variables.</li>
					<li><a href="refmodule.html">Modules</a>. Modules are <i>global</i> namespaces. They are helpful for organizing
					code across source file programs and packages.
					<p>Modules enclose a wide range of named items, such as:</p>
					<ul>
						<li>Functions</li>
						<li>Global variables</li>
						<li>Named Types</li>
						<li>Nested modules or names borrowed from another module</li>
						<li>Macros and templates</li>
					</ul>
				</li>
				<li><a href="reftypes.html">Method-capable types</a>. These types support the definition of named methods and fields.
					A type's public methods and fields may be applied to instances of that type.</li>
			</ul>
		</p>

		<p>Namespaces facilitate a module architecture in several ways.
				Prudent use of namespaces reduces the accidental risk of name collisions, where two
				different items (created possibly by different authors) are given the same name.
				Namespaces also support encapsulation, helping to ensure that implementation details
				are not visible outside of the namespace.</p>
	
		<p>The rules governing names and namespaces vary depending on the type of namespace.</p>

		<h2>Name uniqueness</h2>
		<p>Module, block, and function parameters restrict names so that 
			only one item in that namespace may use a specific name. 
			A compiler error results whenever a name is reused within these namespaces.</p>
		<p>However, types do allow the definition of multiple methods that share the same name.
			Such polymorphism makes it possible to gracefully support the same fundamental semantic capability
			across many different types of parameters.</p>

		<h2>Forward references</h2>
		<p>For the most part, module and type namespaces support forward references.
			This means that code within a module or type may refer to a name that will be defined later in that code.
			However, permissions and allocators do not support forward references.
		  These must be defined before they can be used.</p>
		<p>Blocks do not support forward references. A local variable must be declared before it can be used.</p>
	
		<h2>Name visibility</h2>
		<p>All names defined within a namespace are visible (may be referenced) within that namespace.
			The rules for when a name may be referenced by code external to the namespace
			vary depending on the kind of namespace, as the following sections describe.</p>

			<h3>Local Name Visibility</h3>
			<p>A function's (or method's) local names consist of its parameters,
				as well as all local variables and named (nested) functions or closures
				that are declared within any of its blocks.
				A closure's bound variables are also considered local names.</p>
			<p>Once a local name has been declared, it may be referenced at any point afterwards
				within the block's scope it is declared within, 
				as well as within any block that lies within that lexical scope.
				The only exception to this would be if any inner block defines
				a local variable of the same name, which then takes precedence within that inner scope.</p>
			<p>A function cannot reference any local named declared by another function.
				This is true even for functions or closures declared within another function.
				Even a closure's bound variables are local only to that closure.</p>

			<h3>Methods and Fields: Public vs. Private</h3>
			<p>All of a type's methods and fields may be referenced by any of its methods' code.
				However, only a type's <i>public</i> methods or fields may be referenced
				by code external to the type.
			  All such references are made using the dot ('.') operator.</p>
			<p>Method and field names that begin with an underscore are considered private.
					Otherwise, the name is public, making it referenceable by code outside the type's namespace.</p>
	
			<h3>Module Names: Public vs. Private</h3>
			<p>Any named item declared as part of a module may be referenced by any code within that module
				(including inside any of its functions or type's methods).
				However, only the module's public names may be referenced by code outside that module.
				As with types, private names begin with an underscore.</p>
			<p>The only way to reference a name belonging to another module
				(even a module nested inside another module) is through the use of a 
				<a href="refmodule.html#pathname">qualified path name</a>.</p>
	
			
	<p style="text-align: right; margin-top: 2em;">
		<a href="refmodule.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>