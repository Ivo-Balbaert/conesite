<html>
  <head>
	  <title>If, Match and Conditional Logic - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">If, Match and Conditional Logic</div>
		</div>

    <div class="text">

	<p><span class="pre">if</span> and <span class="pre">match</span> are control structures
	that determine which code block to perform based on the evaluated result of one or more conditional expressions.</p>
	
	<h2>if vs. match</h2>
	<p>Let's use a simple number comparison to illustrate how 
	<span class="pre">if</span> and <span class="pre">match</span> work.
	<h3 id="if">if</h3>
	<p>In this heavily commented example, the code block to perform is determined
	by comparing a combined roll of two die with 7:</p>
<pre>
// Is roll equal to 7?
if roll == 7
  // If so, assign result to "Perfect"
  result = "Perfect"

// Otherwise ("else if"), is roll less than 7?
elif roll &lt; 7
  // If so, assign result to "Too low!"
  result = "Too low!"

// Otherwise (since the roll is not 7 nor less than 7)
else
  // Assign result to "Too high!"
  result = "Too high!"
</pre>
	<p>Every <span class="pre">if</span> structure follows these rules:</p>
	<ul>
	<li>It begins with <span class="pre">if</span> followed by a
	<a href="#condexp">conditional expression</a> and then a block of statements.
	In this example, <span class="pre">roll == 7</span> is the conditional expression.
	A block may hold one or more multiple statements.</li>
	<li>Any number of <span class="pre">elif</span> structures may follow (including none).
	Each specifies its own conditional expression and a block of statements.</li>
	<li>If specified, a single <span class="pre">else</span> structure comes last.
	It has no conditional expression; only a block of statements.</li>
	</ul>
	<p>Since <span class="pre">if</span> may be used as an expression, the above code can be simplified to:</p>
<pre>
result = if roll == 7
  "Perfect"
elif roll &lt; 7
  "Too low!"
else
  "Too high!"
</pre>
	<p>If a block has multiple statements, the expression in the last statement of the block
	is used as the value of that block.</p>
	<p>The above example can also be written on a single line:</p>
<pre>
result = if roll == 7 {"Perfect"} elif roll&lt;7 {"Too low!"} else {"Too high!"}
</pre>

	<h4>if clause</h4>
	<p>When an <span class="pre">if</span> structure has only a single block containing only a single statement,
	this can be written on a single line by appending an <span class="pre">if</span> clause to the statement:</p>
<pre>
bignumber = true if nbr &gt; 100
</pre>
	<p>That line is exactly equivalent to:</p>
<pre>
if nbr &gt; 100
  bignumber = true
</pre>

	<h3 id="match">match</h3>
	<p>The <span class="pre">match</span> statement works similarly to <span class="pre">if</span>.
	Its purpose is to match a single value against a list of patterns.
	In effect, it splits up a conditional expression into two parts: the value to match and a list of 
	patterns to match it against using the <span class="pre">~~</span> operator.</p>
	<p>Here is the earlier example rewritten using match:</p>
<pre>
result = match roll
with 7
  "Perfect"
with 1 .. 6    // Using a range of values as a match pattern
  "Too low!"
else
  "Too high!"
</pre>
	<p><span class="pre">match</span> has a number of other tricks up its sleeves,
	described in depth <a href="#match">later in this chapter</a> once we have
	described the powerful <a href="#matchop">match operator</a>.</p>
	
	<h2 id="condexp">Conditional Expressions</h2>
	<p>A wide variety of conditional expressions can be formulated, from simple equivalence or comparisons
	to complex algorithms that use logical operators, pattern matching, functions or methods.</p>

	<h3>True vs. False</h3>
	<p>A conditional expression evaluates to <span class="pre">true</span> or <span class="pre">false</span>.
	The integer number <span class="pre">0</span>, the <span class="pre">null</span> pointer,
	and <span class="pre">false</span> all evaluate to <span class="pre">false</span>.
	All other values evaluate to <span class="pre">true</span>.
	Thus:</p>
<pre>
// This statement will never execute
a += 1 if 0   // since 0 is equivalent to false

// This statement will always execute
a += 1 if "hello"
</pre>
	<p>These rules make it possible to use function or method calls as part of a conditional expression:</p>
<pre>
a += 1 if a.isOdd
</pre>
	<p>Conditional expressions are not just for <span class="pre">if</span> and <span class="pre">while</span>.
	A conditional expression may be used within any expression:</p>
<pre>
imm isOne Bool = (a == 1)    // isOne will be either true or false
</pre>
	
	<h3>Equivalence Operators</h3>
	<p>The <span class="pre">==</span> operator returns true if two values have the same content and type.
	<span class="pre">!=</span> (not equal) is true if they do not. For example:</p>
<pre>
x == 3.0        // Returns true if the local variable x's value is 3.0
x+1 != y        // Returns true if x is not exactly 1 greater than y
true != false   // Returns true
</pre>
	<p>As with the arithmetic operators, the <span class="pre">==</span> and <span class="pre">!=</span>
	operators are implemented as type-specific methods. 
	Thus, each type can establish its own rules for equivalence.
	For example, two floating point numbers could be evaluated as equal
	if they are within some margin of error (resulting from floating point calculation rounding errors).
	Similarly, two lists might be equal if they have the exact same contents.
	Some types may not implement the <span class="pre">==</span> method.</p>

	<h3>Comparison Operators</h3>
	<p>Comparison operators determine whether one value is greater or less than some other value. 
	They work only on types that are comparable, such as numbers.</p>
<pre>
x &gt;= 2          // Returns true if x is greater than or equal to 2 (&gt;, &lt;, &lt;= are variants)
2 &lt;= 2.0        // Returns false any time the types do not agree
</pre>
	<p>Float values are compared using the same closeness criteria described above.
	For one Float value to be less than another, it must be less by at least the comparable closeness.</p>
	<p>In some cases, a type can make its values comparable by implementing just the
	<span class="pre">&lt;=&gt;</span> (rocket-ship) operator/method.
	This returns an integer (rather than true or false): -1 if less, 0 if equal, and 1 if greater.</p>
<pre>
-2 <=> 4      // Returns -1
</pre>
	<p>Use of the <span class="pre">Comparable</span> trait would then implement the other
	comparison operators using the rocket-ship operator.</p>

	<h3 id="matchop">Pattern Matching Operator</h3>
	<p>The <span class="pre">~~</span> pattern match operator is used to match a value to a specific pattern.
	For example:</p>
<pre>
5 ~~ i32      // true, since the type of 5 is i32
5 ~~ 1 .. 7   // true, since 5 is within the range between 1 and 7
</pre>
	<p>The <span class="pre">~~</span> operator is powerful and unusual:</p>
	<ul>
	<li>It may be used to match a value to a type. 
	The match also succeeds if the value's type is a subtype of the specified type.
	This match could happen at compile-time or run-time.</li>
	<li>If the match pattern is not a type,
	it uses the <span class="pre">~~</span> method on the match pattern.
	Thus, in the example above, the Range type implements the <span class="pre">~~</span> method
	that is used to determine if a value lies within the Range's interval of values.
	<p>Notice that this reverses the usual order for operators which are implemented using methods:
	it is the right-hand value (the match pattern) that must implement the <span class="pre">~~</span> method,
	and the left-hand value which is passed as a parameter to that method.
	Thus, <span class="pre">a~~b</span> is implemented as: <span class="pre">b.`~~`(a)</span>.
	This exception makes the code easier to read and mirrors the order on the 'match' statement, 
	while still putting the matching work on the pattern, where it belongs.</p></li>
	<li>Any type that implements the <span class="pre">==</span> method should
	also implement the <span class="pre">~~</span> method,
	even if only to the same method. Doing so allows the use of the <span class="pre">match</span>
	statement for simple multi-value comparisons.</li>
	<li>The <span class="pre">~~</span> method may be used as an match-and-extract mechanism,
	by returning an extracted value upon a successful match, or else <span class="pre">null</span> if the match fails.
	For example, the match pattern might be a regular expression that returns an extracted string or list of strings
	on a successful match.</li>
	</ul>
	<p>Use of the powerful <span class="pre">~~</span> operator is made possible by the 
	richness of pattern-matching types it is capable of supporting:
	set membership, regular expression, search selectors (e.g., for parts), parsers, input decoder, 
	translater, information analysis, etc.</p>

	<h3>Boolean Operators</h3>
	<p>Acorn has three boolean operators:  
	and ('&&'), or ('||') and not ('!'). One can use either the word or the symbol. 
	For example:</p>
<pre>
0==3 or not 2&lt;3 and 3==3   // Returns true ('and' is evaluated before 'or')
0==3 || !2&lt;3 && 3==3       // equivalent to above
</pre>
	<p>The logical operators work mostly how you would expect:</p>
	<ul>
	<li>As mentioned earlier, they treat 0, null and false as false. All other values are considered true.</li>
	<li>The boolean operators && and || will stop evaluating any time the answer is known for sure.
	Thus, the .isEmpty method will never be performed in this expression (making it similar to a simple 'if' statement):
<pre>
false and list.isEmpty
</pre>
	</li>
	<li>The logical operators have a lower precedence than evaluation operators, but higher than assignment.
	! has the highest precedence, then &&, then ||.</li>
	</ul>
	<p><b>Note:</b> 
	In case it is not obvious by now, these boolean operators are not the same
	as the boolean bit-wise logical operators described earlier.</p>

	<p><b>Note 2:</b>
	If a comparison operator or boolean operator is used outside the context of a control structure
	that wants a conditional expression (e.g., if), in most cases it will evaluate to a value of 'true' or 'false'.
	If the conditional expression just uses 'and' or 'or' operators, its value will be the
	last value evaluated in that expression.</p>

	<h2 id="match">Match statement</h2>
	<p>Now that we have talked about the <span class="pre">~~</span> pattern match operator,
	let's return to the <span class="pre">match</span> statement which makes use of that operator.
	By default, the 'match' statement uses the '~~' method 
	to match each successive pattern against the value of the 'match' statement's value.</p>

	<h3>The 'using' clause</h3>
	<p>Append a 'using' clause to the 'match' statement to specify a 
	specific method to use for matching (as opposed to using the default '~~'):</p>
<pre>
match number using `==`
with 0
	.turn
with 1
	.jump
</pre>
	<p>The using clause can specify any method name or an executable function or closure.</p>

	<h3>Multiple patterns on a 'when'</h3>
	<p>A 'with' statement can list multiple match patterns, separated by commas.
A match on any of those match patterns activates that code block.</p>
<pre>
match number using '=='
with 0,1
	.turn
with 2,3,4
	.jump
</pre>

	<h>Extracting match results</h3>
	<p>Some patterns do more than matching.
	They also extract or transform matched elements within a successfully matched source value, 
	returning one or more new digested value
	(so long as the first returned value is not false or null, which indicates a match failure).
	Specify the variables names that hold these returned values with an 'into' clause
	at the end of the 'match' statement:</p>
<pre>
match command into thing
with +Regex"fight [*]"
	combat: true
	opponent: thing
with +Regex"use [*]"
	.use(thing)
</pre>
	<p>Regex returns the portion of the Text that lies within the square brackets.
	So, if command was "fight Lux", the first match would succeed and thing would be set to "Lux".</p>
	<p>Alternatively, the return variable name(s) may be specified on any specific 'with' statement:</p>
<pre>
match command
with +Regex"fight [*]" into npc
	combat: true
	opponent: npc
with +Regex"use [*]" into item
	.use(item)
</pre>
		
		<p style="text-align: right; margin-top: 2em;">
			<a href="refloop.html"><img alt="_" src="next.png" /></a>
		</p>

	</div>
	</body>
</html>