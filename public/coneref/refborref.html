<html>
  <head>
	  <title>Borrowed References - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Borrowed References</div>
		</div>

    <div class="text">

		<p>Borrowed references offer a straightforward introduction to references.
			Remember this example from the previous page?
		</p>
<pre>
mut a = 3
imm ref = &amp;a    // ref holds a reference to a's contents
imm val = *ref  // val is now 3
*ref = 4        // a is now set to 4
</pre>

		<p>The <span class="pre">&amp;a</span> on the second line creates a borrowed reference.
		Borrowed references point to a value which has already been allocated in some other way.
		Thus, they are "borrowing" the pointer address from something that already knows where the value is stored.
		Unlike allocated references, borrowed references don't know
		how the value was created nor do they manage its memory existence in any way.
		Instead, borrowed references simply have a known, limited lifetime,
		guaranteed to last no longer than the reference they borrow from or the value they point to.
		</p>
		
		<p>This page describes how borrowed references are declared, shows how they are created and used,
			and explains the lifetime mechanisms that help ensure borrowed references stay memory safe.</p>

	<h2 id="dcl">Borrowed Reference Declarations</h2>
	<p>An explicit type declaration for 'ref' in the earlier example would look like this:</p>
<pre>
imm ref <span class="pre">&i32</span> = &amp;a
</pre>
	<p>The type declaration for a reference always begins with <span class="pre">&amp;</span>.
		What follows can be up to four pieces of information which correspond to the reference
		mechanisms mentioned on the previous page. These are specified in this order:</p>
	<ul>
		<li><b>Lifetime</b>. Most of the time, the lifetime of a borrowed reference need not be specified,
		as a reference typically takes on the lifetime of the variable or reference it borrows from.
		Only function parameters or return values will sometimes require explicit lifetime specification,
		as discussed later in the <a href="#lifeannot">lifetime annotations</a> section.</li>
		<li><b>Allocator</b>. This is never specified for a borrowed reference.
			The absence of a specified allocator is how you know it is a borrowed reference.</li>
		<li><b>Permission</b>.
			The <span class="pre">const</span> permission is the default given when no permission is specified.
			<span class="pre">const</span> grants a reference the ability to view the contents of the object but not change it.
			If you want to be able to be able to change the value the reference points to,
			you will need to explicitly specify some other <a href="refperm.html">permission</a>.
		<li><b>Value Type</b>.
			This specifies the type of the value that the reference points to
			(e.g., <span class="pre">i32</span> in the example above).</li>
	</ul>
	<p>To summarize, borrowed reference type declarations always need to specify the value type.
		However, only references that want to mutate the value will need to specify a permission.
		Far rarer are function signatures that require lifetime annotations on parameter or return references.
	</p>

	<h2>Creating a Borrowed Reference</h2>
	<p>There are several ways to create a borrowed reference.</p>
	<h3>Borrowing from a variable</h3>
	<p>As already demonstrated, one may borrow a reference to any global, local or parameter variable:</p>
<pre>
imm glovar = 2
fn func(imm parm)
	mut localvar = 3
	imm ref1 = &amp;glovar
	imm ref2 = &amp;parm
	imm ref3 = &amp;mut localvar
</pre>

	<p>If no permission is specified, <span class="pre">const</span> is assumed.
		A permission may be explicitly specified, as was done for <span class="pre">ref3</span>,
		where the reference is given the shared, mutable permission, allowing it to change the value it points to.
		A requested permission must be allowed by the source variable. 
		For example, it would be prohibited to obtain a mutable reference to an immutable variable.</p>
	<p>Notice that the <i>variable</i> 'ref3' that holds the reference is itself immutable
		(it can only ever refer to 'localvar'). However, it holds a <i>reference</i> able to change (mutate) 'localvar'.
		In this statement, 'imm' prohibits the variable 'ref3' from being changed,
		whereas the implicit 'mut' allows the value pointed at by ref3 to be changed.
		These are separable concerns.</p>
			
	<h3>Borrowing from another reference</h3>
	<p>Any kind of reference (including an <a href="refallocref.html">allocated reference</a>) 
		may be implicitly coerced into a borrowed reference.
		This sort of coercion happens when passing any reference to a function or method
		that expects a differently-typed reference:</p>
<pre>
// This function accepts a borrowed const reference
fn incr(nbr &amp;i32)
	 *nbr + 1

fn main()
	imm allocref = &amp;rc 1   // An allocated reference pointing to an allocated value of 1
	incr(allocref)         // 2. Coerces the allocated uni reference to a borrowed const reference
</pre>
	<p>Because <i>any</i> reference may be safely coerced to a borrowed reference,
		functions and methods typically accept borrowed references as parameters.
		This offers two huge benefits:</p>
	<ul>
		<li>it makes these functions and methods polymorphic across allocators and permissions at no cost</li>
		<li>it eliminates the runtime performance overhead of reference counting (for the rc allocator)
			and reference tracing (for a tracing GC allocator) within these functions.</li>
	</ul>
	<p>It is also possible to explicitly borrow a reference from an existing reference.
		Do so by de-referencing the source reference as part of the borrow:</p>
<pre>
imm allocref = &amp;rc 1
imm borref = &*allocref
</pre>

	<h3 id="internal">Borrowing within a struct or array</h3>
	<p>Only a borrowed reference may point to some value that lies within an allocated value,
		such as a field in a <a href="refstruct.html">struct</a> 
		or an element in an <a href="refarray.html">array</a>-based collection.
		This is how to do it:
	</p>
<pre>
imm ref1 = &amp;apoint.x   // a field within a struct
imm ref2 = &amp;vec[a]     // an element within an array
</pre>
	<p>This interior reference capability is versatile in several ways:</p>
	<ul>
		<li><b>Reference sources are auto-dereferenced</b>.
		When the expression begins with a struct or array reference, it is automatically dereferenced
		(for programmer convenience):
<pre>
// pointref is a reference to a Point structure
imm ref3 = &amp;pointref.x   // equivalent to:  &amp;*pointref.x
</pre>
		</li>
		<li><b>Methods can return the requested reference</b>.
			Rather than directly calculating an interior address statically, 
			it is possible to invoke a method capable of taking a reference as self and
			logically calculating some interior reference based on that and other parameters.
			For example:
<pre>
imm ref4 = &amp;pointer.someref(key)  // passes &amp;pointer as self to someref method. Returns a reference
</pre>
		<p>For some types, this is how borrowing a reference using [] indexing may be processed: invoking a method named `&[]`.</p>
		</li>
		<li><b>Interior borrows support address chains</b>.
			Obtaining a borrowed reference follows the entire sequence of post-fix based operations in an expression,
			making possible address chains like:
<pre>
imm ref3 = &amp;vec[3].point.x
</pre>
		<p>Each stage of such an address chain begins with a reference and ends with an interior reference.
			Parentheses should be used, where needed, to clearly demark where such an address chain ends.
		</p>			
		</li>
	</ul>

	<h3>Borrowing a function or method reference</h3>
	<p>A reference may be borrowed from any named function or method.
	That reference may be used to call the function it refers to.</p>
<pre>
fn incr(x i32) i32
  x + 1

fn caller()
  imm fnref = &amp;incr   // Get a borrowed reference to a function
  fnref(4)            // Call incr and return 5
</pre>
	<p>Using a similar technique, it is also possible to make use of anonymous functions:</p>
<pre>
fn caller()
  imm fnref = &amp;fn (nbr i32) i32 {nbr+1}
  fnref(4)            // Return 5
</pre>
<p>Note, it is not possible to dereference a borrowed function reference using the '*' operator.
	Its permission forbids that. All you can do with a function reference
	is pass it around and use it to call the function it points to.</p>

	<h2>Reference Use (Dereferencing)</h2>
	<p>Use of a borrowed reference typically focuses only on the value it references.
	The <span class="pre">*</span> dereferencing operator may be used to handle this explicitly.
	Within expressions, dereferencing retrieves the value the reference points to.
  Used to the left of an assignment operator, dereferencing changes that value.</p>
<pre>
mut a = 3
imm ref = &amp;a    // ref holds a reference to a's contents
imm val = *ref  // val is now 3
*ref = 4        // a is now set to 4
</pre>

	<p>It is not always necessary to explicitly dereference a borrowed reference to use it,
	since a reference is understood to be a stand-in for the value it references.
	Dereferencing happens implicitly when using the <span class="pre">.</span> operator
	to access a field or call a method on some value pointed to by a reference:</p>
<pre>
mut a = -4
imm ptr = &amp;mut a
imm y = ptr.abs    // y is 4. Similar to: (*ptr).abs
</pre>
	<p>With method calls, it is important to note that self receives the the reference rather than the value.</p>
			
	<h2>Nullable References</h2>
	<p>By default, references can only point to valid values.
		However, it is possible to explicitly declare and use
		<a href="refnullref.html">nullable references</a>.
		A nullable reference can have the value <span class="pre">null</span>,
		which means the reference does not point to any valid value.</p>
		<p>The type signature for a nullable reference specifies a <span class="pre">?</span>
		after the ampersand:</p>
<pre>
imm ref4 &?i32		    	// borrowed, 'const' nullable reference
</pre>
		
		<p>To ensure safety, access to a nullable reference's value is only possible if
			the code first ensures the reference does not have the value of <span class="pre">null</span>:
		</p>
<pre>
// This condition is true only if maybePoint is not null ...
if (!maybePoint)
		imm point = *maybePoint // ... allowing us to obtain its value
imm point2 = *maybePoint    // **ERROR** We don't know if maybePoint is null here
</pre>
	
	<h2>Reference Operations</h2>
	<p>References are values. As such, they can be stored and passed around a program.
		Whether such transfers are simple copies or moves depends on the reference's type
		(particularly its permission and allocator).
		Reference transfers also check reference type information to ensure everyone is in agreement
		about what you can do with any passed-around reference.</p>
	<p>In general, references are treated as stand-ins for the values they refer to.
		Operations on references will nearly always apply to the value the reference refers to,
		rather than the references themselves.
	  However, there are a few operations which do operate directly on references:
		dereferencing, comparison, and reinterpretation.</p>

	<h3>De-referencing</h3>
	<p>As several examples have demonstrated, the <span class="pre">*</span> operator is used to access a reference's value.
		This is called de-referencing. De-referencing a reference is sometimes prohibited based on
		its permission or whether it might have null as a value.</p>
	<p>For most operations on a reference, a reference is automatically de-referenced before performing the operation.
		For example:</p>
<pre>
// Assume ref1 is a reference to an integer
imm sum = ref1 + 4        // equivalent to *ref1 + 4
</pre>

	<h3>Comparison</h3>
	<p>Two references may be compared for equality, but only if they have the same type signature</p>
<pre>
// Do ref1 and ref2 point to the same value?
if ref1 == ref2
    // do some stuff
</pre>
	<p>It is also possible to compare whether one pointer is greater than another.
		This is typically only meaningful if both refer to somewhere within the same object.</p>

	<h3>Reinterpretation</h3>
	<p>The 'as' operator may be used to take an existing reference and create a new reference
		with a different type signature.
		Whenever this might create some safety risks, use of the 'as' operator will need to happen within a 'trust' blocks.
	</p>
<pre>
imm newref = oldref as &Point  // Coerce a reference to a borrowed reference
</pre>

	<h2 id="lifetime">Reference Lifetimes</h2>
	<p>At last we get to what can sometimes be a frustrating aspect of borrowed references:
		lifetime constraints.
		Their purpose is to protect against a borrowed reference pointing to a value that no longer exists. Consider:</p>
<pre>
fn getval() i32
	mut ref &amp;i32
	do
	  imm a = 5
	  ref = &amp;a
	*ref   // Oops!
</pre>
  <p>The scope of the variable 'a' lasts only for the duration of the do block.
		So when we are done executing that block, the variable 'a' ceases to exist.
		However, 'ref' (which points to 'a') continues to exist, but now points to a value that is gone.
		When we dereference it, we are problematically trying to retrieve a value that is no longer there.
		The purpose of lifetime reference constraints is to prevent this from ever happening.</p>
	<p>Lifetime constraints forbid a reference from pointing to a value whose
		lifetime is shorter than its lifetime.
		Within a single function, this is accomplished by comparing when their respective scopes end.
		If the scope for a value happens sooner than any reference trying to point to it,
		Cone will simply not allow changing the reference to point to that value.
		Thus, the line <span class="pre">ref = &a</span> will trigger a compile error,
		since the do block that the 'a' value belongs to ends before the function block that 'ref' belongs to.</p>

		<h2 id="match">Partial match</h2>
		<p>Tbd.</p>
	
			
			<p style="text-align: right; margin-top: 2em;">
		<a href="refallocref.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>