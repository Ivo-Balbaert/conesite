<html>
  <head>
	  <title>Borrowed References - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Borrowed References</div>
		</div>

    <div class="text">

	<p>Borrowed references are different from owning references:
		they neither know nor care which region owns the value they point to.
		As the name suggests, borrowed references are created to point to values that already exist in memory.</p>
	<p>A very common scenario is when we have some existing value and, for some limited lexical scope,
		we want a reference able to work with that value.
		A borrowed reference is ideal for this requirement because:</p>
	<ul>
		<li>Borrowed references may point to nearly any value accessible to program logic,	
			including any variable, locked value, field, array element,
			function, method, or any value pointed at by another reference.
			This versatility makes it possible to create generic functions or methods able to
			work with referred-to values no matter which region they were allocated in.</li>
		<li>A borrowed reference is as fast as any reference can be,
			as it never incurs any of the runtime bookkeeping cost borne by some owned references.</li>
	</ul>

	<h2>Creating a Borrowed Reference</h2>
	<p>Here are several ways to borrow a reference to some existing value.</p>

	<h3>Borrowing from a variable</h3>
	<p>Place the ampersand operator in front of any variable's name
		to create a borrowed reference that points to the value held by that variable.
		This works equally well on any global, local or parameter variable:</p>
<pre>
imm glovar = 2
fn func(parm i32)
	mut localvar = 3
	imm ref1 = &amp;glovar    // ref1's type: &i32
	imm ref2 = &amp;parm      // ref2's type: &i32
	imm ref3 = &amp;localvar  // ref3's type: &i32
</pre>

	<h3>Borrowing from another reference</h3>
	<p>To explicitly create a borrowed reference out of some owning (or borrowed) reference,
		place the ampersand operator in front of a de-referenced reference:</p>
<pre>
imm allocref = &amp;rc 1
imm borref = &*allocref    // Borrow from allocref
</pre>
	<p>In most cases, however, borrowing a reference from an existing reference
		can be handled implicitly, as part of a function (or method) call or assignment.
		This happens when the receiver is given an owning reference but expects a borrowed reference.
		So long as the value type (and permission) match, the borrow is performed automatically.</p>
<pre>
// This function accepts a borrowed reference
fn incr(nbr &amp;i32)
  *nbr + 1

fn main()
  imm allocref = &amp;rc 1   // An owning reference pointing to an allocated value of 1
  incr(allocref)         // Coerces the rc reference to a borrowed reference
</pre>
	<p>Because <i>any</i> reference may be safely coerced to a borrowed reference,
	functions and methods typically accept borrowed references as parameters.
	This capability is what makes possible the benefits mentioned earlier:</p>
	<ul>
		<li>Functions and methods can be polymorphic across allocators and permissions at no cost</li>
		<li>Using borrowed references avoids the runtime performance overhead of reference counting (for the rc allocator)
			and reference tracing (for a tracing GC allocator) within these functions.</li>
	</ul>

<h3 id="internal">Referring to a field or array element</h3>

	<p>Unlike an owning reference, a borrowed reference may point to a value within some composite value,
		such as a field in a <a href="refstruct.html">struct</a> 
		or an element in an <a href="refarray.html">array</a>.
		Again, all we need to do is apply the ampersand operator:
	</p>
<pre>
imm ref1 = &amp;apoint.x   // a field within a struct
imm ref2 = &amp;vec[a]     // an element within an array
</pre>
	<p>This kind of internal borrow is quite powerful, as it supports:</p>
	<ul>
	<li><b>Internal reference chains</b>.
		One can reference values within values within values, by chaining together
		fields or indexing:
<pre>
imm ref3 = &amp;vec[3].point.x
</pre>
	<p>Parentheses should be used, where needed, to clearly demark where an internal reference chain ends.
	</p>			
	</li>
	<li><b>Methods in place of fields</b>.
		A method name may be specified (instead of a field name) after the dot operator.
		This calls the method, passing it the reference evaluated so far (as <span class="pre">self</span>),
		and returning a borrowed reference calculated by the method's logic.
		For example:
<pre>
imm ref4 = &amp;pointer.someref(key)  // passes &amp;pointer as self to someref method. Returns a reference
</pre>
	<p>Similarly (for some types), using the indexing operator <span class="pre">[]</span>
		will invoke the type's <span class="pre">[]</span> method to obtained the borrowed reference.</p>
	</li>
	<li><b>Auto-dereferencing a reference source</b>.
		When an internal reference expression begins with a reference as the source, it is automatically dereferenced:
<pre>
// pointref is a reference to a Point structure
imm ref3 = &amp;pointref.x   // equivalent to:  &amp;*pointref.x
</pre>
	</li>
	</ul>

	<h2>Permissions</h2>
	<p>Like owning references, borrowed references may specify a permission which
		governs what may be done with the reference.
		This permission is specified after the ampersand operator:</p>
<pre>
mut a = 3
imm ref = &amp;mut a   // Creates a mutable borrowed reference to a's value
*ref = 4           // a is now set to 4
</pre>
	<p>The permission requested must be allowed by the source we are borrowing from.
		For example, a mutable borrowed reference may not be obtained from an immutable variable.</p>

	<h3 id="const">const Permission</h3>
	<p>If no permission is specified when creating a borrowed reference
		(as demonstrated in earlier examples),
		the <span class="pre">const</span> permission is assumed.
		A <span class="pre">const</span> reference may read its value, but may not modify that value.
		This description may sound like <span class="pre">imm</span>, but it is not the same.
		<span class="pre">imm</span> guarantees that <i>no</i> other mutable reference to the same object exists,
		making it safe to share between threads. <span class="pre">const</span> makes no such guarantee.
		Therefore, <span class="pre">const</span> references cannot be safely shared with another thread.</p>
		<p>The primary value of <span class="pre">const</span> is how it makes polymorphic
		any functions and methods that promise to not change a referred-to value. 
		By declaring a reference parameter as <span class="pre">const</span>,
		the function or method can safely accept references which the caller sees as
		<span class="pre">mut</span>, <span class="pre">imm</span>, <span class="pre">uni</span>,
		or <span class="pre">const</span>.
		For this reason, <span class="pre">const</span> is the effectively
		the commonly-used, universal receiver for other permissions.
		This is why creating a borrowed reference
		defaults to <span class="pre">const</span> when no permission is specified.</p>			

	<h2 id="lifetime">Lifetime Constraints</h2>
	<p>The most distinguishing safety constraint on borrowed references is that
		their lifetime is temporary.
		Carefully managing the lifetime of a borrowed reference is needed for memory and race safety,
		as it:</p>
	<ul>
	<li>Prevents it from pointing to any value with a shorter lifetime.</li>
	<li>Freezes out access to the "source" of the borrowed reference for its lifetime.</li>
	</ul>

	<h3>Lifetime Comparisons</h3>
	<p>To ensure memory safety, a reference may never survive longer than the value it points to.
		This example demonstrates the importance of this restriction:</p>
<pre>
fn getval() i32
	mut ref &amp;i32
	do
	  imm a = 5
	  ref = &amp;a
	*ref   // Oops!
</pre>
  <p>The scope of the variable <span class="pre">a</span> lasts only for the duration of the do block.
	So when we are done executing that block, the variable <span class="pre">a</span> ceases to exist.
	However, <span class="pre">ref</span> (which points to <span class="pre">a</span>) continues to exist, 
	but now points to a value that is gone.
	When we dereference it, we are problematically trying to retrieve a value that is no longer there.</p>
  <p>To protect against this sort of safety violation,
	the lifetime of a reference is never allowed to grow longer than the lifetime
	of the value it points to.
  The latter, at-least-as-long-as lifetime of the value is captured as part of the reference when borrowed:</p>
  <ul>
	<li>For a global value, the lifetime is <span class="pre">'static</span>
		(the entire lifetime of the program).</li>
	<li>For a parameter or local variable, the lifetime is the lexical scope
		that variable is declared within.</li>
	<li>When borrowing from another reference, we use the lexical scope
		active when this borrowing took place, since we know the value it points
		at will last at least as long as the reference it borrows from.</li>
	<li>For any borrowed reference we have not witnessed the creation for
		(passed as a parameter or returned by another function),
		a <a href="reflifetime.html">lifetime annotation</a> may be required
		to indicate the minimum-possible lifetime of the pointed-at value.</li>
	</li>
  </ul>
	<p>When the borrowed reference is first created, it starts off with a very short and safe lifetime,
		only lasting as long as the expression it was created within.
	  This lifetime can be extended by storing it in a longer-lasting container
	  such as a variable, another reference, field, array element, etc.
	  When a reference's lifetime is extended, we check it against the reference's captured lifetime for the value.
	  As the above example demonstrates, it is a compile error 
	  to store a borrowed reference into a container whose lifetime exceeds the
	  reference's captured value lifetime.</p>

	<h3>Freezing access to the source of a borrow</h3>
	<p>When a borrowed reference is created, its source is always a named variable.
		That source variable either holds or points to the value we are borrowing a pointer to.
		When we borrow from the source, we are not just gaining access to the value,
		we are also gaining some or all of its access permissions.</p>
	<p>Whenever we borrow from a source with <span class="pre">uni</span> permission,
		which guarantees only one live reference can exist to the value at a time,
		the source variable is made inaccessible for the lifetime of the borrowed reference
		in order to preserve that guarantee:</p>
<pre>
fn freeze(n i32)
  imm uniref = &one 3       // has permission uni
  if n &gt; 1
	imm borref = &*uniref   // borrowing make uniref inaccessible in this block 
    imm m = *uniref         // oops! uniref may not be accessed
</pre>

	<h2>Using a Borrowed Reference</h2>
	<p>Basically, you can use any borrowed reference much the same way as any owning reference:
		dereference it, compare it, etc.
	</p>


	<p style="text-align: right; margin-top: 2em;">
		<a href="refrefborrow.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>