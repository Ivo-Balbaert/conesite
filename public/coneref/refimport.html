<html>
  <head>
	  <title>include, import, and extern - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">include, import, and extern</div>
		</div>

    <div class="text">
	
	<p>When building programs, it can be very useful to make use of reusable code libraries
		written by others. Such libraries are distributed as <b>packages</b>.</p>

	<h2>import</h2>
	<p>To make use of a package in your program, employ the 
		<span class="pre">import</span> command in the global area:</p>
<pre>
import math3d
import opengl
</pre>

	<p>This example imports two packages. 
		Cone's build tool (Congo) will automatically find, download, and prepare
		these packages for inclusion in your program.
		Thereafter, you can make use of the types, functions, templates, macros
		that are defined by these packages as if they were now a part of your program.
	</p>
	<p>A package name may be enclosed in double quotes, if desired.
		This option is useful when a package's name includes symbols not allowed in a variable name.
		It may also be used whenever one wants to refer to a package
		using the folder or URL path where the package may be found.
	</p>
	
	<p><b>Note:</b> It is never necessary to import the standard library (std). 
	It is automatically included as part of every program.</p>
	
	<h3>Old text for modules</h3>
	<p>The previous import page indicated that external libraries are imported as packages.
			In addition, any program or library you are building is also a package.
			A package, not a source file, is the basic unit of compilation.</p>
		<p>A package is a collection of one or more source files that are transformed by the Congo build system
			into a specific program or library.
			This page describes how to name and organize the source files for your program or library across folders,
			as well as the language features used to bind them together at build time.
			It also describes how a package's source code can be organized into module namespaces.
			By convention, the names and structure for packages and modules typically map closely to
			how source files are named and organized into folders.</p>
		
		<h2>A Single Source File</h2>
		<p>Each package typically lives in its own base folder.
			So, for a new program, you begin by creating that folder.
			Within it, 'congo new' creates the necessary scaffolding for a new program. 
			In the folder, you will find it created a new 'main.cone' file.
			This name is what Congo starts with when compiling your package.
		</p>
		<p>You can use your favorite editor to modify main.cone, transforming it into the program you want to create.
			To compile it, you only need to invoke 'congo build' within that folder.
		</p>
		<p>If you want to build a library rather than an executable program,
			use 'congo new library' instead. The main source file for a library is called 'lib.cone'.
		</p>
		<p>When your package expands to more than one source file,
			you have two options for binding the source files together:</p>
		<ul>
			<li><span class="pre">include</span>,
				which stitches one source file into another as part of the same namespace.</li>
			<li><span class="pre">mod</span>,
				which creates a separate module namespace.</li>
		</ul>
	
		<h2>include</h2>
		<p>The <span class="pre">include</span> statement
		incorporates another source file's contents as if were made a part of the current source file.
		For example, suppose we had a source file called 'useme.cone':
	<pre>
	fn inc(a i32) i32
		a+1
	</pre>
		<p>Another source file can now use its contents:</p>
	<pre>
	include useme
	fn timesnext(a i32)
		a * inc(a) // uses a function defined by 'useme.cone'
	</pre>
		<p>'useme' is the name of the source file to include (the extension of .cone is assumed, if not specified).
		By default, it looks for this file in the same folder as the source file which includes it.</p>
	
		<h3>Subfolders</h3>
			<p>Sometimes, it is conceptually useful to organize include files in a nested structure,
				mirrored by the structure of the folders that hold the source files.
				The build system offers a simple convention for accomplishing this.</p>
			<p>In the above example, if Congo failed to find 'useme.cone' in the same folder,
				it will look inside the 'useme' subfolder for a file named 'mod.cone'.</p>
	
		<h3>Quoted include files</h3>
			<p>Sometimes, a source file's name or path may need to use punctuation characters not legal in an identifier,
			such as '/' or '.'. When this is the case, simply enclose the file/path name in double quotes:</p>
	<pre>
	include "../useme"
	</pre>
		<p>A specified path may be absolute or relative to the current source file's folder.</p>
	
	<h2>Import</h2>

	<h3>Modules as separate files</h3>
	<p>Typically, a nested module is defined in its own source file and then referenced by any module
	that needs access to its named members. 
	Using <span class="pre">mod</span>, a program can include 'useme.cone' as a module
	(instead of an include file):</p>
<pre>
mod useme
fn timesnext(a i32)
	a * useme::inc(a) // uses a function defined by 'useme.cone'
</pre>
  <p>We need to qualify the inc() function with the module's namespace name to access it,
		exactly as we needed to when we <a href="refpackage.html">import foreign packages</a>
		(which are also treated as module namespaces).
		Indeed, all the advice given there about namespace-qualified names applies here as well.
		Since modules can be nested inside modules, namespace-qualified names
		can get deep (e.g., ip::tcp::http).</p>
	<p>Furthermore, <span class="pre">mod</span> supports the same options as
		<span class="pre">import</span> for folding (and aliasing) 
		specific module names into the current namespace.
    Like <span class="pre">include</span>, <span class="pre">mod</span> also supports
	  automatic folder nesting (e.g., "useme/mod.cone") and quoted filename paths.</p>
	<p>Although <span class="pre">include useme</span> and <span class="pre">mod useme *</span>
	might appear to do the same thing, there are some subtly important differences:</p>
	<ul>
		<li>Every use of include retrieves and parses the file, whereas mod will only
			do this once for any given source file.</li>
		<li>Using mod, the source file's private names (those beginning with an underscore)
			will not become part of the current namespace.</li>
		<li>Processing mod is somewhat slower than include.</li>
	</ul>



		<h2>extern</h2>
	<p>TBD: extern is not about functions/variables. Only usable as a specialized "module".</p>
    <p>It is possible to use of functions that have been implemented in a different language (e.g., C).
	  Such functions still need to be properly declared to Cone.
	  This is done by preceding the function declaration with <span class="pre">extern</span>.
	  No implementation block should be specified, since its logic is implemented elsewhere.
	</p>
<pre>
extern fn printFloat(nbr f32)
</pre>
	<p>An <span class="pre">extern</span> block may be used when multiple external functions require declaration.
	  Externally initialized global variables may also be declared this way.</p>
<pre>
extern
	fn printFloat(nbr f32)
	fn printInt(nbr i32)
	mut indentation
</pre>

	<h2 id="pathname">Namespace Path</h2>
	<p>To reference entities defined by the package, a namespace path may be used
		(since an imported package is treated as a module namespace).
		So we can reference the Point3 type in the math3d package,
		by qualifying (with a double colon) the type's name with the package's namespace:
	</p>
<pre>
fn move(pos &amp;math3d::Point3, delta math3d::Point3)
		pos += delta
</pre>
	<p>Typically, path names are relative to the current module.
		This behavior can be overridden by using one of two special prefixes:</p>
	<ul>
	<li><span class="pre">::</span> begins with the main (root) namespace.</li>
	<li><span class="pre">super::</span> begins with the parent module that owns the current module.</li>
	</ul>

	<h3>Namespace folding</h3>
	<p>The default practice of wrapping the named items of an external packages in its own namespace is hygienic.
     It prevents polluting the program's namespace with unanticipated names that might collide.</p>
	<p>However, frequent use of fully-qualified path names for external package entities
		can get tedious to type and read.
		The <span class="pre">import</span> command provides several ways to fold the package's
		namespace into the current namespace, thereby avoiding the need to qualify a name with a path prefix.</p>
	<p>To fold in specific names from the package's namespace:</p>
<pre>
import math3d Point3, Mat3

fn move(pos &amp;Point3, delta Point3)
		pos += delta
</pre>
  <p>To fold in an alias for specific names:</p>
<pre>
import math3d Point3 as Point

fn move(pos &amp;Point, delta Point)
		pos += delta
</pre>
	<p>Or one can fold in all names from the package using '*':</p>
<pre>
import math3d *

fn move(pos &amp;Point3, delta Point3)
		pos += delta
</pre>
	
	<p style="text-align: right; margin-top: 2em;">
		<a href="refreuse.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>