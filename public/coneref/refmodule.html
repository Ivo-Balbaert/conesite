<html>
  <head>
	  <title>Modules - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Congo, include, and mod</div>
		</div>

    <div class="text">
	
	<p>The previous import page indicated that external libraries are imported as packages.
		In addition, any program or library you are building is also a package.
		A package, not a source file, is the basic unit of compilation.</p>
	<p>A package is a collection of one or more source files that are transformed by the Congo build system
		into a specific program or library.
		This page describes how to name and organize the source files for your program or library across folders,
		as well as the language features used to bind them together at build time.
		It also describes how a package's source code can be organized into module namespaces.
		By convention, the names and structure for packages and modules typically map closely to
	  how source files are named and organized into folders.</p>
	
	<h2>A Single Source File</h2>
	<p>Each package typically lives in its own base folder.
		So, for a new program, you begin by creating that folder.
		Within it, 'congo new' creates the necessary scaffolding for a new program. 
		In the folder, you will find it created a new 'main.cone' file.
		This name is what Congo starts with when compiling your package.
	</p>
	<p>You can use your favorite editor to modify main.cone, transforming it into the program you want to create.
		To compile it, you only need to invoke 'congo build' within that folder.
	</p>
	<p>If you want to build a library rather than an executable program,
		use 'congo new library' instead. The main source file for a library is called 'lib.cone'.
	</p>
	<p>When your package expands to more than one source file,
		you have two options for binding the source files together:</p>
	<ul>
		<li><span class="pre">include</span>,
			which stitches one source file into another as part of the same namespace.</li>
		<li><span class="pre">mod</span>,
			which creates a separate module namespace.</li>
	</ul>

	<h2>include</h2>
	<p>The <span class="pre">include</span> statement
	incorporates another source file's contents as if were made a part of the current source file.
	For example, suppose we had a source file called 'useme.cone':
<pre>
fn inc(a i32) i32
  a+1
</pre>
	<p>Another source file can now use its contents:</p>
<pre>
include useme
fn timesnext(a i32)
  a * inc(a) // uses a function defined by 'useme.cone'
</pre>
	<p>'useme' is the name of the source file to include (the extension of .cone is assumed, if not specified).
	By default, it looks for this file in the same folder as the source file which includes it.</p>

	<h3>Subfolders</h3>
		<p>Sometimes, it is conceptually useful to organize include files in a nested structure,
			mirrored by the structure of the folders that hold the source files.
			The build system offers a simple convention for accomplishing this.</p>
		<p>In the above example, if Congo failed to find 'useme.cone' in the same folder,
			it will look inside the 'useme' subfolder for a file named 'mod.cone'.</p>

	<h3>Quoted include files</h3>
		<p>Sometimes, a source file's name or path may need to use punctuation characters not legal in an identifier,
		such as '/' or '.'. When this is the case, simply enclose the file/path name in double quotes:</p>
<pre>
include "../useme"
</pre>
	<p>A specified path may be absolute or relative to the current source file's folder.</p>

	<h2>mod</h2>
	<p>The alternative to <span class="pre">include</span> is <span class="pre">mod</span>,
	  which marks code as belonging to a distinct module.
	  A module is a global namespace for named types, functions, global variables, 
		metaprogramming constructs, and other modules.
		A module may lie within a source file, be a whole source file,
	  or even span multiple source files. Modules are nestable.</p>
	  <p>Modules are valuable for isolating the names used by large programs.
	  Modules help to avoid situations where different source programs accidentally collide
	  because they use the same name to refer to different things.</p>
	
	<h3 id="global">Global variables</h3>
	<p>Global variables are declared outside of all function blocks.
		Space for them is allocated automatically when a program is loaded for execution.
		Global variables are shared across and accessible by any function at any time.</p>
	<p>Thus:</p>
<pre>
imm glowy i32     // Global immutable variable
fn a_function()
  mut loco f32    // Local mutable variable
</pre>
  <p>The lifetime of global variables is the same as the program's lifetime.
		Global variables come into being when the program starts and disappear when the program stops.</p>

	<h3>Modules as separate files</h3>
	<p>Typically, a nested module is defined in its own source file and then referenced by any module
	that needs access to its named members. 
	Using <span class="pre">mod</span>, a program can include 'useme.cone' as a module
	(instead of an include file):</p>
<pre>
mod useme
fn timesnext(a i32)
	a * useme::inc(a) // uses a function defined by 'useme.cone'
</pre>
  <p>We need to qualify the inc() function with the module's namespace name to access it,
		exactly as we needed to when we <a href="refpackage.html">import foreign packages</a>
		(which are also treated as module namespaces).
		Indeed, all the advice given there about namespace-qualified names applies here as well.
		Since modules can be nested inside modules, namespace-qualified names
		can get deep (e.g., ip::tcp::http).</p>
	<p>Furthermore, <span class="pre">mod</span> supports the same options as
		<span class="pre">import</span> for folding (and aliasing) 
		specific module names into the current namespace.
    Like <span class="pre">include</span>, <span class="pre">mod</span> also supports
	  automatic folder nesting (e.g., "useme/mod.cone") and quoted filename paths.</p>
	<p>Although <span class="pre">include useme</span> and <span class="pre">mod useme *</span>
	might appear to do the same thing, there are some subtly important differences:</p>
	<ul>
		<li>Every use of include retrieves and parses the file, whereas mod will only
			do this once for any given source file.</li>
		<li>Using mod, the source file's private names (those beginning with an underscore)
			will not become part of the current namespace.</li>
		<li>Processing mod is somewhat slower than include.</li>
	</ul>

<h3>Embedded modules</h3>
<p>It is possible to specify a separate module within a source file
using the <span class="pre">mod</span> statement followed by a block.
Its named namespace is effectively nested within the enclosing program's namespace:</p>
<pre>
mod frontend
  fn get() ...

fn main()
  frontend::get() // refers to the get function within the frontend namespace
</pre>

	<h2 id="dyninit">Dynamic initialization of global variables</h2>
	<p></p>
		
	<p style="text-align: right; margin-top: 2em;">
		<a href="refconcur.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>