<html>
  <head>
	  <title>Type Safety - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Type Safety</div>
		</div>

    <div class="text">

	<p>Typing is strict: You cannot put a round peg in a square hole.</p>
	<p>Since all values, expressions and variables have a type, the compiler can (and will)
		check whether the use of types is consistent.
		In most cases, an error will be reported wherever a program:</p>
	<ul>
		<li>Stores a value of one type into a variable or collection declared for a different type.</li>
		<li>Passing an argument of one type to a function that expects a value of another type in that position.</li>
		<li>Returns a value of one type when the function's signature declares a different type for the return value.</li>
		<li>Creates a reference (or pointer) to an object whose type does not match the reference's type declaration.</li>
	</ul>
	<p>These constraints protect against the program manipulating a value in ways that make no sense or could be harmful,
		due to acting as if the value has a different meaning than it actually does.</p>
	<p>However, sometimes we <b>do</b> need to transform a value of one type to another type.
		Cone supports three such capabilities:</p>
	<ul>
		<li><b>Coercion</b>,
			which maps a value to its exact equivalent in a supertype.</li>
		<li><b>Conversion</b>,
			which chooses the closest "equivalent" value in another type.
			This is not a perfect mapping: A valid mapping may not exist or some precision may be lost.</li>
		<li><b>Reinterpretation</b>,
			which keeps the original value but interprets it as if it has a different type.</li>
	</ul>


	<h2 id="coercion">Subtyping and Implicit Type Coercion</h2>
	<p>In many cases, one type can be a <i>subtype</i> of another type.
	  A subtype specializes its more general-purpose supertype, adding additional constraints.
	  Many forms of subtyping are supported:</p>
	<ul>
		<li>A struct is a subtype of any trait it implements or interface it conforms to</li>
		<li>A type is a subtype of any variant type that includes that type as a variation</li>
		<li>A smaller number type is a subtype of a larger version of the same type
			(e.g., u8 is a subtype of u32)</li>
		<li>Some permissions are subtypes of others (e.g., 'const' is a subtype of 'imm')</li>
		<li>Borrowed references are subtype of an equivalently typed allocated reference
			(e.g., &Foo is a subtype of &own Foo)</li>
	</ul>
	<p>Coercion maps a value to its exact equivalent in a supertype.
		Cone will automatically and implicitly coerce a value of some subtype to its supertype
		when a supertype value is expected.
		Commonly, this happens with assignments and function calls:</p>
<pre>
// Implicitly coerce a u8 to u32
imm u8value = 101u8
imm bigint u32 = u8value

// Implicitly coerce &own uni Mat4 to &const Mat4
mut matrix = &own Mat4[]
imm det = mat4det(matrix)
fn mat4det(mat &Mat4) f32
   // ...
</pre>
	<p>Coercion can be requested explicitly by using the 'into' operator:</p>
<pre>
imm bigint = u8value into u32
</pre>

<p>The 'as' operator may be used to take an existing reference and create a new reference
	with a different type signature.
	Whenever this might create some safety risks, use of the 'as' operator will need to happen within a 'trust' blocks.
</p>
<pre>
imm newref = oldref as &Point  // Coerce a reference to a borrowed reference
</pre>

<h2>Type Conversion</h2>
	<p>Type conversion involves transforming a value of one type to its "equivalent" value in another type.
		For example, converting the integer 1 to the floating point number 1.0,
		or serializing it to text:  "1".
		Unlike coercion, conversion may not map perfectly: A valid mapping may not exist or some precision may be lost.
	</p>
	<p>Converting one number type to another uses the <a href="refexpr.html#numrconv">"literal" format</a>
		or the 'into' operator:</p>
<pre>
imm float = f32[1]
imm float = 1 into f32
</pre>
	<p>Beyond number types, conversion is typically requested using the new type's initializer or a method in the old type:</p>
<pre>
imm text = Text(1) // "1"
imm text = 1.text
</pre>

	<h2>Type Reinterpretation</h2>
	<p>Unlike coercion and conversion, reinterpretation does not create a new value.
		It interprets the existing encoded value as if it has a different type.
		The new type must have the same size as the current type of the value.</p>
	<p>Reinterpretation uses the <span class="pre">as</span> infix operator.
		Unlike other infix operators, <span class="pre">as</span> expects a type (rather than a value or expression) 
		to the right of the operator.</p>
	<p>Reinterpretation is mostly used on references, such as when turning a reference into a pointer.</p>
<pre>
	imm ptr = &amp;x as *Vector3
</pre>
	<p>Reinterpretation can be also be used on number types,
		such as when we want to access a floating point number's bits:</p>
<pre>
	imm highword = u32[(pi as u64) >> 32]
</pre>
  	<p>Reinterpretation can be dangerous, as a value could behave badly 
		when treated and manipulated within the constraints of a different type.
		For example, a reference reinterpreted as a pointer loses permission constraints,
		making it possible for a pointer to be used to alter an immutable object.
		It is the responsibility of the programmer to ensure the reinterpreted value
		is handled in a safe and useful manner.</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refstruct.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>