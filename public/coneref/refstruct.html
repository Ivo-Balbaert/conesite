<html>
  <head>
	  <title>structs - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">structs</div>
		</div>

    <div class="text">

	<p>Use the struct type when creating values that contain multiple other values within.
	A struct's member values are called properties.
	Each property has a unique name, a specified type, and possibly a default value.</p>
	<p>As with other types, a struct may implement
		<a href="refmethod.html">methods</a> in addition to properties.
		Additionally, structs may implement <a href="reftrait.html">traits</a>
		and/or variant-type tags, useful features described elsewhere.
	</p>
	<p><b>Note:</b> structs are not the only type to support properties.
		Traits, Interfaces, Allocs, Perms and other types also support properties
		for similar, but more specialized needs.
	</p>
	
	<h2>Declaration</h2>
	<p>First, you must declare a specific struct layout by name. For example:</p>
<pre>
struct Point
    x f32
    y f32
</pre>
	<p>This defines a struct type named Point that contains two properties named x and y.
		Both properties are floating point numbers.
		It is common to capitalize the names of declared types.
	</p>
	<p>Property declarations look just like variable declarations:</p>
	<ul>
		<li>A permission may be specified before the property name.
			If unspecified, <span class="pre">mut</span> is assumed.</li>
		<li>The property's name and type must be specified.
			Property names that begin with an underscore are considered private.
			Private properties cannot be accessed outside of the struct's methods.
		</li>
		<li>A default value may be specified after the type and an equal sign.
			The default value must be a literal and may be used to help initialize a newly created struct.</li>
	</ul>
	<p>Once declared, the struct type may be used the same way as any other type.
	For example, this declares a Point variable:</p>
<pre>
imm pt Point;
</pre>

	<h2>Struct Values</h2>
	<p>A new struct value is created and initialized using a literal or a 
		<a href="refmethod.html#constructor">constructor</a>.</p>

	<h3>Literals</h3>
	<p>A struct literal begins with the struct name followed by the initial values for all properties in curly braces.</p>
	<pre>
	imm pt = Point {x: 3., y: 4.}    // Using property names
	imm pt2 = Point {3., 4.}         // When property names are omitted, order matters.
	</pre>
	<p>Several rules apply to literals:</p>
	<ul>
		<li>A value must be specified for all properties that were not declared with a default value.</li>
		<li>Private properties without a default value prevent the use of literals external to the type's methods.</li>
	</ul>

	<h3>Copy vs. Move</h3>
	<p>Wherever possible, structs (like numbers) are copied whenever assigned to a variable or property, 
		passed as a parameter, or returned as a value. Any change to one copy has no effect on the others.</p>
<pre>
imm pt = Point {x: 3f, y:4f}
imm pt2 = pt     // pt2 is a full copy
pt2.x = 4f       // pt2 changes but pt does not
func(pt2)        // this function call creates a third copy
</pre>
	<p>However, a declared struct type will enforce move semantics if it either:</p>
	<ul>
		<li>Defines any property typed as a <a href="refperm.html#uni">non-aliasable reference</a>
			and does not implement the .clone method), or</li>
		<li>Implements the destructor method</li>
	</ul>
	<p>Values with move semantics are still copied to a new destination, but the original version is no longer accessible.
	    Move semantics enforce that multiple copies of the same object cannot be usable at the same time.</p>
<pre>
struct Node
    nbr: &amp;uni i32
uni life = 42
imm node1 = Node {nbr: &amp;uni life}
imm node2 = node1
imm node3 = node1   // ERROR! node1 is no longer usable
</pre>

	<h3>Object References</h3>		
	<p>struct copying has two potential limitations: a) the larger the struct, the slower the copy,
	b) changing a copy does not change the original. It is possible to address these limitations
	by borrowing a reference to a struct and then passing around and using the reference
	in place of the struct.
<pre>
fn main()
  imm pt = Point {x: 3f, y: 4f}
  imm dist = dist(&amp;mut pt)  // dist may modify the contents of pt
</pre>
	<p>Similarly, an allocator may be used to allocate a new struct.
	The allocator returns a reference to the struct:</p>
<pre>
imm pt = &amp;gc mut Point{x: 3f, y: 4f}
</pre>

	<h2>Property Access</h2>
	<p>Any public property within a struct may be accessed using the <span class="pre">.</span> operator,
	specifying the object on the left and the property name on the right:</p>
<pre>
imm dist = (pt.x*pt.x + pt.y*pt.y).sqrt
</pre>
	<p>Within a struct's methods, only the property name needs to be specified,
		just as if it were a variable.</p>
<pre>
fn dist() f32
    (x*x + y*y).sqrt  // x is equivalent to self.x
</pre>
	<p>A property can be changed by putting the property name to the left of an assignment operator:</p>
<pre>
fn setOrigin(self &amp;mut)
    x,y = 0f,0f
</pre>
	<p><b>Note:</b> From the outside, a property and a computed property (a get/set method)
	look identical. The user of a struct does not care if it is working with a stored value
	or a value mediated by methods.</p>
	
	<h3>Property permissions</h3>
	<p>Mutation of a property is allowed only if the permissions on 
	both the object <i>and</i> the property permit it.</p>

	<h3>Property references</h3>
	<p>It is possible to use the <span class="pre">&amp;</span> operator to 
	obtain a borrowed reference to a specific property within a structure:</p>
<pre>
imm pt = Point{x: 3f, y: 4f}
imm refx = &amp;pt.x
*refx                     // 3f
</pre>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refalloc.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>