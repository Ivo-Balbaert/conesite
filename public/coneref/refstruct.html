<html>
  <head>
	  <title>structs - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">structs</div>
		</div>

    <div class="text">

	<p>A struct holds one or more named values (fields), each with its own type.
			The struct's fields are located together in memory
			and can be individually accessed using the field's name.</p>
	<p>Let's illustrate by declaring a new struct type:</p>
<pre>
struct Liner
  line [80] u8
  pos u32
</pre>
	<p>This defines a new struct type called <span class="pre">Liner</span> that holds two fields of data.
		The field named <span class="pre">line</span> is an array of 80 bytes.
		The field named <span class="pre">pos</span> is an unsigned integer.</p>
	<p>Variables can be declared using this new type, each with its own values in these two fields:</p>
<pre>
imm liner1 = Liner[line: [80; ' '], pos: 0u]
mut liner2 = Liner[line: [80; '\0'], pos: 10u]
</pre>
	<p>This page focuses on using structs to hold field-oriented data.
		Subsequent pages will enrich what can be done with a struct by adding
		<a href="refmethod.html">method</a> and <a href="refinherit.html">trait</a> definitions.</p>
	
	<h2>Declaration</h2>
	<p>Before we can make use of a specific data structure,
		we need to declare it, giving it a name and specifying its fields:</p>
	</p>
<pre>
struct Point
    x f32 = 0.
    y f32 = 0.
</pre>
	<p>The struct's declared name is effectively new, custom-defined type.
		This type name can be used to declare any number of variables containing values of this type
	  (e.g., <span class="pre">imm pt1 Point</span>).</p>
	<p>Field declarations look like variable declarations, specifying the field's:</p>
	<ul>
		<li><b>Permission.</b>
			The actual permission that governs field access is derived from
			both the field's and struct's permissions
			using a mechanism called <a href="refperm.html#view">viewpoint adaptation</a>.
			If unspecified, <span class="pre">mut</span> is assumed,
			which effectively means the struct value's permission governs access.</li>
		<li><b>Name.</b>
			Each field must be given a unique name.
			However, names used in one struct will not be confused with same-named
			fields in other types, nor with variable or function names.
			<p>Field names that begin with an underscore are considered pr\ivate.
			Private fields can only be accessed by the struct's methods.
			Fields should be private if we don't want logic outside the struct's methods
			to depend on this implementation detail or be able to change its value directly.
			This is particularly important when the field's value should be subject to
			additional invariant constraints that are properly enforced by the struct's methods.</p>
			<p>The anonymous name <span class="pre">_</span> may be used for
			any data segment of the struct that we don't want or need access to.</p></li>
		<li><b>Type.</b>
			This can be any type:  numeric, Bool, an array, some other struct, etc.
			The name <span class="pre">Self</span> may be used to refer to the struct
			type currently being defined.
			There is one important restriction: A field's type may not be the same
			as the struct type we are declaring (or any recursive variation on this).
			A field's type, however, may be a <a href="refrefs.html">reference</a> to the struct type.
		</li>
		<li><b>Default value.</b>
			The default value must be a constant.
			Specifying default values makes initialization of a newly created struct more convenient.</li>
	</ul>

	<h2>Initialization</h2>
	<p>The initial value for any struct value is always built 
		(explicitly or implicitly) using a struct constructor:
	the struct name followed by comma-separated field values in square brackets.
	Values may be marked with field names or just listed in declared order:</p>
<pre>
imm pt = Point [x: 3., y: 4.]    // Using field names
imm pt2 = Point [3., 4.]         // When field names are omitted, order matters.
imm pt3 = Point[]                // Uses x,y's declared default values of 0.
</pre>
	<p>Several constraints apply to struct constructors:</p>
	<ul>
		<li>The constructor must specify a value for every field lacking a default value.</li>
		<li>Only the type's methods may use the struct constructor,
			if the struct has any private field lacking a default value.</li>
	</ul>
	<p>It is also possible to initialize a new struct value by using one of the struct's defined
		<a href="refmethod.html#init">initializer methods</a> instead.
		Under the covers,
		initializer methods also use the struct constructor to initialize the struct's value.</p>
	
	<h2>Copying</h2>
	<p>Like numbers, struct values may be passed around between variables and functions:</p>
<pre>
fn main()
	imm pt1 = Point[]
	pt1 = change(pt1)

fn change(mut pt Point)
	pt = Point[1., 2.]
	pt
</pre>
	<p>Copies of the data structures are made as they are passed around
		(e.g. into and returned by <span class="pre">change</span>).
		Any changes made to a copy won't change the original struct value.
		This may not always be the behavior that you want, though.
		If a struct is too big to pass around efficiently,
		or you want changes to apply to the source structure,
		make use of <a href="refrefs.html">references</a> to a struct instead.</p>

	<h2>Field Access</h2>
	<p>Use the <span class="pre">.</span> operator to access a struct field's value,
	specifying the struct value on the left and the field name on the right:</p>
<pre>
imm dist = (pt.x*pt.x + pt.y*pt.y).sqrt
</pre>
	<p>A field's value may also be altered in this way:</p>
<pre>
pt.y = pt.x
</pre>
	<p>The compiler applies field privacy and permission constraints to prevent invalid field accesses.
		A private field can only be accessed by the type's methods.
		Changing of a field's value is only allowed if the struct/field permissions allow mutability.</p>

	<p>It is also possible to use the <span class="pre">&amp;</span> operator to 
	<a href="refborref.html#internal">borrow a reference</a> to a specific field within a struct value.</p>

	<h2>Comparing</h2>
	<p>It is not possible to check whether two structs have the same value if the struct defines only fields.
		However, two struct values may be compared if the struct implements
		the <a href="refmethod.html#compare">comparison methods</a>.
		Also, it is possible to perform <a href="refmatch.html#struct">partial matching</a>
		of a struct against some pattern.
	</p>

	<h2 id="opaque">Opaque Types</h2>
	<p>A struct declared with no fields is called an <b>opaque type</b>.
		It is typically used when we want to be able to point to data whose structure is a mystery
		(built built and managed by some external system).
		Since its content and size is unknown, one cannot create a new value of this type,
		pass such a value around, or directly access its fields.
		However, it is possible to pass around a reference to an opaque-typed value
		which some external function has created, as well as invoke any methods defined for it.</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refenum.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>