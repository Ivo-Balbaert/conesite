<html>
  <head>
	  <title>Trust - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Trust</div>
		</div>

    <div class="text">
	
	<p>On functions and blocks</p>

	<h3>Trust blocks: Relaxing Safety Checks</h3>

	<p>The compiler comes with built-in guard rails to help protect your code
		against a number of safety hazards, which is a good thing.
		However, these safety guards are extremely cautious and not always very clever.
		They stop your code from doing things that, under the worst of all possible conditions,
		could cause memory or race conditions.
		Sometimes this means they stop your code from doing things that you want to do,
		and which you can ensure by other means is perfectly safe,
		but the compiler just does not know how to verify.
	  The compiler is trying to be helpful, but is just getting in the way.</p>
	<p>In such situations, Cone provides a built-in escape hatch from the guard rails,
		in the form of an annotation. 
		By preceding any block with <span class="pre">trust</span> 
		(as in:  "trust me on this"), several safety checks are turned off,
		thereby allowing:</p>
		<ul>
		  <li>Raw pointer dereferences, arithmetic, and re-casts.
				This provides a way to get around the many constraints imposed on references
				by permissions, lifetimes, allocators and bounds-checks.
			</li>
			<li>Use of functions written in and imported from other languages.
				This is normally disallowed since most other languages are not as
				rigorous in verifying the safety of the code.
			</li>
			<li>Static mutable variable access and mutation.
				This guard exists to protect against race conditions in multi-threaded code.
			</li>
			<li>Non-discriminated unions</li>
			<li>Type reinterpretation</li>
		</ul>
		<p>Safety is enriched when the programmer and the compiler work together
			towards that end, each bringing different gifts to bear on the problem.
			It would not be fair to imply that the compiler's inability to verify safety
			means that the code is inherently unsafe.
			By using this "trust" mechanism, compiler-unverifiable code can be
			isolated and highlighted as such, while still acknowledging
			that the programmer, who has the ultimate responsibility for safety,
			may very clearly see what the compiler cannot.
		</p>

	<h2>Type Reinterpretation</h2>
	<p>Unlike coercion and conversion, reinterpretation does not create a new value.
		It interprets the existing encoded value as if it has a different type.
		The new type must have the same size as the current type of the value.</p>
	<p>Reinterpretation uses the <span class="pre">as</span> infix operator.
		Unlike other infix operators, <span class="pre">as</span> expects a type (rather than a value or expression) 
		to the right of the operator.</p>
	<p>Reinterpretation is mostly used on references, such as when turning a reference into a pointer.</p>
<pre>
imm ptr = &amp;x as *Vector3
</pre>
	<p>Reinterpretation can be also be used on number types,
		such as when we want to access a floating point number's bits:</p>
<pre>
imm highword = u32[(pi as u64) >> 32]
</pre>
		<p>Reinterpretation can be dangerous, as a value could behave badly 
		when treated and manipulated within the constraints of a different type.
		For example, a reference reinterpreted as a pointer loses permission constraints,
		making it possible for a pointer to be used to alter an immutable object.
		It is the responsibility of the programmer to ensure the reinterpreted value
		is handled in a safe and useful manner.</p>
	
			<p style="text-align: right; margin-top: 2em;">
			<a href="refptr.html"><img alt="_" src="next.png" /></a>
		</p>
		
	</div>
	</body>
</html>