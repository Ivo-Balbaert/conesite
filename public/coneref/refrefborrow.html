<html>
  <head>
	  <title>Borrowing References - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Borrowing References</div>
		</div>

    <div class="text">

		<p>Borrowed references offer a straightforward introduction to references.
			Remember this example from the previous page?
		</p>
<pre>
mut a = 3
imm ref = &amp;a    // ref holds a reference to a's contents
imm val = *ref  // val is now 3
*ref = 4        // a is now set to 4
</pre>

		<p>The <span class="pre">&amp;a</span> on the second line creates a borrowed reference.
		Borrowed references point to a value which has already been allocated in some other way.
		Thus, they are "borrowing" the pointer address from something that already knows where the value is stored.
		Unlike allocated references, borrowed references don't know
		how the value was created nor do they manage its memory existence in any way.
		Instead, borrowed references simply have a known, limited lifetime,
		guaranteed to last no longer than the reference they borrow from or the value they point to.
		</p>
		
		<p>This page describes how borrowed references are declared, shows how they are created and used,
			and explains the lifetime mechanisms that help ensure borrowed references stay memory safe.</p>

	<h2 id="dcl">Borrowed Reference Declarations</h2>
	<p>An explicit type declaration for 'ref' in the earlier example would look like this:</p>
<pre>
imm ref <span class="pre">&i32</span> = &amp;a
</pre>
	<p>The type declaration for a reference always begins with <span class="pre">&amp;</span>.
		What follows can be up to four pieces of information which correspond to the reference
		mechanisms mentioned on the previous page. These are specified in this order:</p>
	<ul>
		<li><b>Lifetime</b>. Most of the time, the lifetime of a borrowed reference need not be specified,
		as a reference typically takes on the lifetime of the variable or reference it borrows from.
		Only function parameters or return values will sometimes require explicit lifetime specification,
		as discussed later in the <a href="#lifeannot">lifetime annotations</a> section.</li>
		<li><b>Allocator</b>. This is never specified for a borrowed reference.
			The absence of a specified allocator is how you know it is a borrowed reference.</li>
		<li><b>Permission</b>.
			The <span class="pre">const</span> permission is the default given when no permission is specified.
			<span class="pre">const</span> grants a reference the ability to view the contents of the object but not change it.
			If you want to be able to be able to change the value the reference points to,
			you will need to explicitly specify some other <a href="refperm.html">permission</a>.
		<li><b>Value Type</b>.
			This specifies the type of the value that the reference points to
			(e.g., <span class="pre">i32</span> in the example above).</li>
	</ul>
	<p>To summarize, borrowed reference type declarations always need to specify the value type.
		However, only references that want to mutate the value will need to specify a permission.
		Far rarer are function signatures that require lifetime annotations on parameter or return references.
	</p>
		
			<h3>Borrowing a function or method reference</h3>
	<p>A reference may be borrowed from any named function or method.
	That reference may be used to call the function it refers to.</p>
<pre>
fn incr(x i32) i32
  x + 1

fn caller()
  imm fnref = &amp;incr   // Get a borrowed reference to a function
  fnref(4)            // Call incr and return 5
</pre>
	<p>Using a similar technique, it is also possible to make use of anonymous functions:</p>
<pre>
fn caller()
  imm fnref = &amp;fn (nbr i32) i32 {nbr+1}
  fnref(4)            // Return 5
</pre>
<p>Note, it is not possible to dereference a borrowed function reference using the '*' operator.
	Its permission forbids that. All you can do with a function reference
	is pass it around and use it to call the function it points to.</p>

	<h2>Reference Use (Dereferencing)</h2>
	<p>Use of a borrowed reference typically focuses only on the value it references.
	The <span class="pre">*</span> dereferencing operator may be used to handle this explicitly.
	Within expressions, dereferencing retrieves the value the reference points to.
  Used to the left of an assignment operator, dereferencing changes that value.</p>
<pre>
mut a = 3
imm ref = &amp;a    // ref holds a reference to a's contents
imm val = *ref  // val is now 3
*ref = 4        // a is now set to 4
</pre>

	<p>It is not always necessary to explicitly dereference a borrowed reference to use it,
	since a reference is understood to be a stand-in for the value it references.
	Dereferencing happens implicitly when using the <span class="pre">.</span> operator
	to access a field or call a method on some value pointed to by a reference:</p>
<pre>
mut a = -4
imm ptr = &amp;mut a
imm y = ptr.abs    // y is 4. Similar to: (*ptr).abs
</pre>
	<p>With method calls, it is important to note that self receives the the reference rather than the value.</p>
			
	<h2>Nullable References</h2>
	<p>By default, references can only point to valid values.
		However, it is possible to explicitly declare and use
		<a href="refnullref.html">nullable references</a>.
		A nullable reference can have the value <span class="pre">null</span>,
		which means the reference does not point to any valid value.</p>
		<p>The type signature for a nullable reference specifies a <span class="pre">?</span>
		after the ampersand:</p>
<pre>
imm ref4 &?i32		    	// borrowed, 'const' nullable reference
</pre>
		
		<p>To ensure safety, access to a nullable reference's value is only possible if
			the code first ensures the reference does not have the value of <span class="pre">null</span>:
		</p>
<pre>
// This condition is true only if maybePoint is not null ...
if (!maybePoint)
		imm point = *maybePoint // ... allowing us to obtain its value
imm point2 = *maybePoint    // **ERROR** We don't know if maybePoint is null here
</pre>
	
	<h2>Reference Operations</h2>
	<p>References are values. As such, they can be stored and passed around a program.
		Whether such transfers are simple copies or moves depends on the reference's type
		(particularly its permission and allocator).
		Reference transfers also check reference type information to ensure everyone is in agreement
		about what you can do with any passed-around reference.</p>
	<p>In general, references are treated as stand-ins for the values they refer to.
		Operations on references will nearly always apply to the value the reference refers to,
		rather than the references themselves.
	  However, there are a few operations which do operate directly on references:
		dereferencing, comparison, and reinterpretation.</p>

	<h3>De-referencing</h3>
	<p>As several examples have demonstrated, the <span class="pre">*</span> operator is used to access a reference's value.
		This is called de-referencing. De-referencing a reference is sometimes prohibited based on
		its permission or whether it might have null as a value.</p>
	<p>For most operations on a reference, a reference is automatically de-referenced before performing the operation.
		For example:</p>
<pre>
// Assume ref1 is a reference to an integer
imm sum = ref1 + 4        // equivalent to *ref1 + 4
</pre>

	<h3>Comparison</h3>
	<p>Two references may be compared for equality, but only if they have the same type signature</p>
<pre>
// Do ref1 and ref2 point to the same value?
if ref1 == ref2
    // do some stuff
</pre>
	<p>It is also possible to compare whether one pointer is greater than another.
		This is typically only meaningful if both refer to somewhere within the same object.</p>

	<h3>Reinterpretation</h3>
	<p>The 'as' operator may be used to take an existing reference and create a new reference
		with a different type signature.
		Whenever this might create some safety risks, use of the 'as' operator will need to happen within a 'trust' blocks.
	</p>
<pre>
imm newref = oldref as &Point  // Coerce a reference to a borrowed reference
</pre>

		<h2 id="match">Partial match</h2>
		<p>Tbd.</p>
	
			
			<p style="text-align: right; margin-top: 2em;">
		<a href="refrefborrow.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>