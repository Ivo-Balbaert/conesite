<html>
  <head>
	  <title>enums - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">enums</div>
		</div>

    <div class="text">
	<p style="margin-left: 40px;"><i>Note: None of this capability is currently implemented.</i></p>

	<p>From a type perspective, the structure of a struct or array value is quite fixed.
	This is restrictive when we need values whose structure can vary based on runtime logic.
	This is what enum (and union-based) types address.
	They allow a value's type structure to vary as signalled by its captured "tag".</p>

	<p>Enums hold a single value whose type could be one of several variations.
		For example:</p>
<pre>
enum Number
	Integer i32
	Float   f32
</pre>
	<p>This defines a new enum type called <span class="pre">Number</span>
		which holds a single numeric value.
		That value <i>could</i> be an integer or a floating-point number, but not both.
		Unlike with structs, <span class="pre">Integer</span> and <span class="pre">Float</span> 
		are not separate fields stored in different locations.
			They are instead two possible overlays on a single memory location.</p>
		<p>Under the covers, enum values also hold a hidden field called the "tag".
		In this example, the tag indicates whether the value currently holds an integer
		(tag field = 0) or a floating-point number (tag field = 1).
	</p>
	
	<h3>Declaration</h3>
	<p>As the example shows, an enum type declaration resembles a struct declaration.
		It begins by giving a name to this new, custom-defined type.
	  The variant types options are listed within, each specifying the option's:</p>
	<ul>
		<li><b>Name.</b>
			As the option name represents a type, it is typically capitalized.
			Names should not begin with (or be) an underscore.
		  A name may be the same as the name of the type specified for this variant.</li>
		<li><b>Type.</b>
			This is the type of any value of this option.
			A type need not be specified when this option is not attached to a value.
			Alternative, the specified may be a set of fields enclosed in curly braces.
			This is understood to mean the type is a struct that includes the defined fields.</li>
		<li><b>Tag Value.</b>
			Normally, a number is automatically assigned to each variant for the tag,
			starting with 0 and incrementing upwards on each option.
			This tag number may be explicitly indicated, if desired.</li>
		</ul>
	<p>This declaration specifies three variant types:</p>
<pre>
enum OddEnum
	None          // No value for this variant
	SomeInt i32   // Value is an integer
	PointStruct   // Value is a struct holding two floats
		x f32
		y f32
</pre>
	<p><b>Note:</b>
		enums can be used to associate names to constant numbers.
		Just leave out type information:
	</p>
<pre>
enum Colors
	Red   = 0xFF0000
	Green = 0x00FF00
	Blue  = 0x0000FF
</pre>

		<h3>Initialization</h3>
		<p>An enum initial value is built using the enum constructor:</p>
<pre>
mut oddval = OddEnum::None
oddval = OddEnum::SomeInt[34]
oddval = OddEnum::PointStruct[x: 4., y: 8.]
</pre>

		<h3>Copying</h3>
		<p>An enum value may be passed around, by copy, just like any other value.
			This is possible because all variant values of a specific enum type are the same size.
			The enum type's size is effectively the size of its largest variant type
			plus the size of its hidden tag field.
		</p>

		<h3>Value Access</h3>
		<p>To safely gain access to the differently-typed value enclosed with an enum value,
			we must use <a href="refmatch.html">pattern matching</a>.
			As a brief peek into the versatile power of partial pattern matching,
			consider this example:</p>
<pre>
match oddval
	~~ intval = SomeInt:     intval
	~~ point = PointStruct:  i32[point.x * point.y]
	None:                    0
</pre>
		<p>The <span class="pre">match</span> statement allows us to determine which type of data
			this <span class="pre">OddEnum</span> value holds.
			If it is an integer, it will match on the first option and (as part of the match) copy that integer into
			a new variable called <span class="pre">intval</span>.
			For this variant, the logic indicates that the match expression should evaluate to this integer's value.
			And so it goes for matching against any of the other variants.</p>
		<p>One may also match an enum value against a single variant using an
			<span class="pre">if</span> statement:</p>
<pre>
sum += intval if oddval ~~ intval=SomeInt
</pre>
	<p><b>Note:</b>If an enum value is being matched against a variant that has no value
		(e.g., <span value="pre">none</span> above), the equivalence operator 
		<span class="pre">== </span> may be used
		instead of the partial match operator <span class="pre">~~</span>, if desired.</p>
	</p>

	<h3>Comparing</h3>
	<p>An enum value may only be compared for equivalence (and not order).
		The equivalence check compares the tag fields first.
		If they are equal, the appropriately-typed interior values are compared
		using the <span class="pre">==</span> method.</p>

	<h2>Option and Result Types</h2>

	<p>Two particular enum patterns are so pervasive that special
		support is baked in to make them easier to use:</p>
	<ul>
		<li><b>Result</b>. The value can be either a valid value or
			an exception value.</li>
		<li><b>Option</b>. The value can be either a valid value or
		  <span class="pre">null</span> ("not a value").</li>
	</ul>

	<h3 id="result">Result Type</h3>
	<p>In our earlier discussion about <a href="refexcept.html">exception handling</a>,
		we introduced the idea that some functions can choose to throw an exception value
		on failure and a regular value on success.
		This is actually just a Result value being returned.
		Built-in language syntax just makes it clearer and simpler to work with such values:</p>
	<ul>
		<li>A function whose return signature is <span class="pre">i32 throws Bool</span> is
			another way to write a Result type: <span class="pre">Result&lt;i32, Bool&gt;</span></li>
		<li><span class="pre">return 3</span> is equivalent to <span class="pre">return ok[3]</span>.</li>
		<li><span class="pre">throw false</span> is equivalent to <span class="pre">return err[false]</span>.</li>
	</ul>
	<p>The <span class="pre">?</span> operator (try) and <span class="pre">||</span> operator (or else)
		offer more concise and readable ways to perform various common patterns for applying
		pattern matching blocks against a Result value.</p>

	<h3 id="option">Option Type</h3>
	<p>The Option type is useful when we want to express the idea that
		we may or may not have a value of a certain type.
		<span class="pre">null</span> is the name used to represent the absence of a value.
		<span class="pre">some[x]</span> represents some specific value.
		Nullable values are needed so often that special syntax exist to make them easier to use.</p>
	<p>To declare a nullable type, simply put a question mark before the type.
		For example:</p>
<pre>
mut maybeInt ?i32 = null   // Initial value indicates the absence of a value
if maybeInt == null        // or: if !maybeInt
  maybeInt = 4             // Give it the value 4
</pre>
	<p>If the type of a declared variable is omitted but an initial value is specified,
		the initial value needs to be wrapped in the <span class="pre">some</span> constructor:</p>
<pre>
mut maybeInt = some[4]
</pre>
	<p><b>Nullable References</b>
		Although we have not covered references yet, it is worth nothing here that
		nullable references take no more space than regular references.
		The null reference value is just a non-addressable address (typically, 0).
	</p>

	<h3>nullable operators</h3>
	<p>The <span class="pre">?</span> and <span class="pre">||</span> operators
		that are so helpful for Result values can also be applied to
		nullable values.</p>

	<h4>Give null a default value</h4>
	<p>Use the <span class="pre">||</span> operator to establish
		a real value in the event of null.</p>
<pre>
imm val = maybeInt || 0
</pre>
	<p><span class="pre">val</span> will be the value of <span class="pre">maybeInt</span>
		if it is not null. Otherwise it will be 0.
		The value to the right of the operator cannot be a nullable type,
		and its type must match that of a valid value for the nullable value on the left.</p>

	<h4>Handle null as an exception</h4>
	<p>Use the <span class="pre">?</span> operator to treat 
		a <span class="pre">null</span> value as an exception.</p>
<pre>
imm val = maybeInt?
</pre>
	<p><span class="pre">val</span> will be the value of <span class="pre">maybeInt</span>
		if it is not null. Otherwise it will panic.</p>
	<p>If a <span class="pre">catch null</span> handler is provided, it will
		be invoked instead of a panic.</p>

	<h4>null propagation</h4>
	<p>A variation of the method call operator allows safe method calls on
		a nullable value:</P>
<pre>
imm x = maybePoint?.dist
</pre>
	<p>In effect, this propagates nullability from 
		<span class="pre">maybePoint</span> to <span class="pre">x</span>.
		If <span class="pre">maybePoint</span> holds a valid value,
		the method is called and its return value is wrapped as nullable.
		If <span class="pre">maybePoint</span> is null,
		then so will <span class="pre">x</span> be.</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refunion.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>