<html>
  <head>
	  <title>Allocated references - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Allocated references</div>
		</div>

    <div class="text">

	<p>Programming languages offer a way to dynamically allocate new values.
	  And if a language enforces memory safety, as most languages do,
	  it uses an automatic memory management mechanism (such as tracing garbage collection)
	  to ensure that allocated values are automatically freed when no longer needed.
	  Most languages bake in a single memory management strategy, take it or leave it.</p>
	<p>In Cone, allocated references handle these memory management responsibilities.
	  They do so in a versatile way: <i>each</i> allocated reference specifies
	  which memory management strategy allocates its value and manages its lifetime.
	  One reference might use reference counting, another reference garbage
	  collection, and a third a Rust-like single-owner model (RAII with escape analysis).
	  Each memory strategy has distinct advantages and disadvantages.
	  Cone's versatility allows a program to select the optimal mix of strategies that best satisfies its requirements.
	</p>
	<p>A reference in Cone is either an allocated reference or a borrowed reference.
	  Using allocated references looks largely like use of borrowed references, but there are differences.
		An allocated reference owns the reference that a borrowed reference borrows from.
	  Thus, an allocated reference may be coerced to a borrowed reference, but not vice-versa.
	  The handling of allocated references sometimes carries extra runtime costs
	  that borrowed references never do.
		Allocated references cannot point to substructures the way a borrowed reference can.
    </p>
	<p>This page describes how allocated references are declared, shows how they are created,
		and explains the memory management mechanisms that allocators use to ensure memory safety.</p>

	<h2>Allocated reference Declarations</h2>
	<p>As with borrowed references, the type declaration for an allocated reference 
		begins with <span class="pre">&amp;</span>.
		The reference mechanics follow:</p>
	<ul>
		<li><b>Lifetime</b>. Allocated references never specify a lifetime, as it is inferred.</li>
		<li><b>Allocator</b>. This is the memory management strategy used to allocate
			and manage the lifetime of an allocated value. We will get into the details of this
			<a href="#allocators">soon</a>.
			The presence of a specified allocator is how you know it is a allocated reference.</li>
		<li><b>Permission</b>.
			The <span class="pre">uni</span> permission is the default given when no permission is specified.
			<span class="pre">uni</span> grants a reference the ability to view or change the reference's value.
			This is the universal donor permission, allowing mutation and inter-thread movement,
			but restricting aliasing to a single live reference.
			Extensive information about <span class="pre">uni</span> and other permissions
			is covered on the <a href="refperm.html">permissions</a> page.
		<li><b>Value Type</b>.
			This specifies the type of the value that the reference points to.</li>
	</ul>
	<p>To summarize, allocated reference type declarations always need to specify the allocator and value type.
		A permission is specified when different from <span class="pre">uni</span>. For example:</p>
<pre>
imm aref1 &amp;lex i32
imm aref2 &amp;rc mut i32
</pre>

	<h2>Creating an Allocated reference</h2>
	<p>There is only one way to create an allocated reference:
		Specify the <span class="pre">&</span> operator, followed by the allocator, an optional permission, 
		and then either specify its initial value or use a <a href="refmethod.html#constructor">type constructor</a>:
	</p>
<pre>
imm rcref = &amp;lex 45                     // Allocate a new boxed value, initialized with 45
imm gcref = &amp;gc mut Point3(1f, 2f, 3f)  // Allocate a new Point3 value using a constructor
</pre>
	<p>Creating an allocated reference is quite different than creating a borrowed reference.
	  With a borrowed reference, we are simply obtaining the already-known address of some value.
	  With an allocated reference, we are actually allocating a new place in memory
	  with enough space to hold a value of the desired type. That memory space
	  is initialized using the provided value or constructor.
	  The returned allocated reference points to this newly created value.</p>

	<h2 id="allocators">Standard Allocators</h2>
	<p>Cone supports several standard allocators, each corresponding to a specific memory management strategy.
	Allocators vary in how they allocate and free memory,
	as well as the lifetime algorithm they use to determine when it is safe to automatically free an allocated memory segment,
	knowing that no more usable references exist that point to it.</p>
	<p>There is no one perfect approach to memory management.
	  Each allocator has its specific advantages and disadvantages.
	  The art lies in choosing the right mix of strategies that best meets the program's requirements
	  for performance, memory utilization, and data structure complexity.</p>
	</p>
	<h3>lex - RAII with escape analysis</h3>
	<p>Only one allocated reference may point to any lex-allocated value.
	  That reference may be passed around from function to function or from thread to thread.
	  The memory for that value is automatically dropped and freed when its single reference goes out of its last scope.
	  lex is similar to Rust's Box&lt;T&gt; single-owner mechanism.</p>
	<p>The key benefits are performance, deterministic drops, and memory efficiency.
	  The performance benefit comes from avoiding the need for runtime bookkeeping,
	  since the allocated value's lifetime can be determined at compile time.
	  The biggest downside is its data structure inflexibility.
	  It cannot safely handle data structures that require multiple allocated references to the same value,
	  such as all cyclic and many directed acyclic graphs.</p>
	<p><b>Note:</b> A lex allocated reference only accepts the 'uni' or 'imm' permissions.
	It is not possible to alias a lex allocated reference.
	Any attempt to do so simply moves the reference to a new binding.</p>

	<h3>rc - Reference Counting</h3>
	<p>When a new rc reference is created, it is initialized with a counter that is set to 1.
	Every time an alias (copy) is made of an rc allocated reference, the counter is incremented.
	Whenever a reference goes out of scope, the counter is decremented.
	When the counter reaches 0, the value is dropped and freed.</p>
	<p>The key benefits are memory efficiency, deterministic drops, simple mechanism,
	  and much better data structure flexibility than lex.
	  The biggest downsides are performance (due to cache-unfriendly runtime bookkeeping)
	  and memory leakage when dealing with cyclic data structures.
	  The latter weakness can be ameliorated sometimes through the use of weak references.
	</p>

	<h3>gc - Tracing Garbage Collection</h3>
	<p>A record is kept of every new allocation. Periodically, the garbage collector traces out
	  all references reachable from a required root collection (including the execution stack).
	  Any allocated value that cannot be traced from the root is considered unreachable,
	  and therefore is safe to automatically drop and free.</p>
	<p>The primary benefit is its flexibility: it supports any kind of data structure,
	and usually does so with better performance than rc.
	The chief drawbacks are its runtime bookkeeping costs (regular tracing and sweep cycles),
	unpredictable stop-the-world lag spikes, non-deterministic (and possibly delayed) drop and free,
	and the complexity of its implementation and tuning (particularly for multi-threaded garbage collection).</p>

	<h3>arena - Regional</h3>
	<p>This strategy makes efficient use of a pre-allocated (and growable) arena of memory.
	  Every new allocation takes a bite out of this arena using a fast bump pointer.
	  Allocations are never individually freed. The entire slab is freed as a single event 
	  when the arena itself goes out of scope.</p>
	<p>The primary benefit is speed: allocation and free are much faster
		than malloc or equivalent, and there are no run-time bookkeeping costs.
		The chief drawbacks are memory waste (because nothing is freed until the arena goes out of scope)
		and the inability to support drop finalizers.</p>

	<h3>pool - Fixed-size Pool</h3>
	<p>Similar to arena, this strategy makes use of a pre-allocated (and growable) memory area
	  that has been divided up into identically-sized slots.
	  Each new allocation quickly grabs some unused slot.
	  Reference counting is used to determine when an allocation is freed (marking its slot as reusable).</p>
	<p>The primary benefit of pool is memory efficiency and 
		a much faster allocation and free of size-limited values than is possible using malloc.
		The chief drawbacks are the size limits on values
	    and the runtime bookkeeping costs of its underlying lifetime algorithm.</p>
	
	<p style="text-align: right; margin-top: 2em;">
		<a href="refperm.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>