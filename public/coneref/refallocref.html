<html>
  <head>
	  <title>Allocator References - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Allocator References</div>
		</div>

    <div class="text">

	<p>Programming languages offer a way to dynamically allocate new values.
	  And if a language enforces memory safety, as most languages do,
	  it uses an automatic memory management mechanism (such as tracing garbage collection)
	  to ensure that allocated values are automatically freed when no longer needed.
	  Most languages bake in a single memory management strategy, take it or leave it.</p>
	<p>In Cone, allocator references handle these memory management responsibilities.
	  They do so in a versatile way: <i>each</i> allocator reference specifies
	  which memory management strategy allocates its value and manages its lifetime.
	  One reference might use reference counting, another reference garbage
	  collection, and a third a Rust-like single-owner model (RAII with escape analysis).
	  Each memory strategy has distinct advantages and disadvantages.
	  Cone's versatility allows a program to select the optimal mix of strategies that best satisfies its requirements.
	</p>
	<p>Using allocator references looks like use of borrowed references.
	  There are differences, however. 
	  Allocator references cannot point to substructures the way a borrowed reference can.
	  An allocator reference may be coerced to a borrowed reference, but not vice-versa.
	  The handling of allocator references sometimes carries extra runtime costs
	  that borrowed references never do.
    </p>
	<p>This page describes how allocator references are declared, shows how they are created,
		and explains the memory management mechanisms that allocators use to ensure memory safety.</p>

	<h2>Allocator Reference Declarations</h2>
	<p>As with borrowed references, the type declaration for an allocator reference 
		begins with <span class="pre">&amp;</span>.
		The reference mechanics follow:</p>
	<ul>
		<li><b>Lifetime</b>. Allocator references never specify a lifetime, as it is inferred.</li>
		<li><b>Allocator</b>. This is the memory management strategy used to allocate
			and manage the lifetime of an allocated value. We will get into the details of this
			<a href="#allocators">soon</a>.
			The presence of a specified allocator is how you know it is a allocator reference.</li>
		<li><b>Permission</b>.
			The <span class="pre">uni</span> permission is the default given when no permission is specified.
			<span class="pre">uni</span> grants a reference the ability to view or change the reference's value.
			This is the universal donor permission, allowing mutation and inter-thread movement,
			but restricting aliasing to a single live reference.
			Extensive information about <span class="pre">uni</span> and other permissions
			is covered on the <a href="refperm.html">permissions</a> page.
		<li><b>Value Type</b>.
			This specifies the type of the value that the reference points to.</li>
	</ul>
	<p>To summarize, allocator reference type declarations always need to specify the allocator and value type.
		A permission is specified when different from <span class="pre">uni</span>. For example:</p>
<pre>
imm aref1 &amp;lex i32
imm aref2 &amp;rc mut i32
</pre>

	<h2>Creating an Allocator Reference</h2>
	<p>There is only one way to create an allocator reference:
		Specify the <span class="pre">&</span> operator, followed by the allocator, an optional permission, 
		and then either specify its initial value or use a <a href="refmethod.html#constructor">type constructor</a>:
	</p>
<pre>
imm rcref = &amp;lex 45                     // Allocate a new boxed value, initialized with 45
imm gcref = &amp;gc mut Point3(1f, 2f, 3f)  // Allocate a new Point3 value using a constructor
</pre>
	<p>Creating an allocator reference is quite different than creating a borrowed reference.
	  With a borrowed reference, we are simply obtaining the already-known address of some value.
	  With an allocator reference, we are actually allocating a new place in memory
	  with enough space to hold a value of the desired type. That memory space
	  is initialized using the provided value or constructor.
	  The returned allocator reference points to this newly created value.</p>

	<h2 id="allocators">Standard Allocators</h2>
	<p>Cone supports a wide variety of allocators, each of which varies in how they manage 
	and determine when to free the memory used by the values they allocate.
	Ultimately, the following flavors of allocators will be possible:</p>
	<ul>
	<li><b>lex</b>, used to create a single-owner allocator reference which is automatically dropped and freed
	at the end of the last lexical block it is moved into. The benefits of lex are that its reference's lifetimes
	can be statically determined (avoiding runtime bookkeeping costs) and the free happens both promptly and deterministically.
	The downside of lex is that it prohibits shared allocator (owner) references, which are needed
	to support many data structures.</li>
	<li><b>arena</b>, used to rapidly create sharable allocator references which are all freed together
	when the lexical lifetime of the arena expires.
	The primary benefit of arena is speed: allocation and free are much faster and there are no run-time bookkeeping costs.
	The chief drawbacks are memory inefficiency (due to delayed freeing) and its lexical limitations.</li>
	<li><b>rc</b> (ref-counted), used to create sharable allocator references, whose allocated value is freed
	when no reference exists to it. The primary benefits of rc are shared ownership of references
	without any lexical constraints and the simplicity of the mechanism.
	The chief drawbacks are its runtime bookkeeping costs (cache-breaking changes to reference counts)
	and its memory inefficiency with unbroken data structure cycles (which may never get freed).</li>
	<li><b>gc</b> (tracing garbage collection), used to create sharable allocator references, whose allocated
	value is freed when the allocated value is no longer accessible (traceable) from the program's root values.
	The primary benefit of gc is its flexibility: it supports any data structure with no lexical constraints,
	and does so usually with better performance than rc.
	The chief drawbacks are its runtime bookkeeping costs (regular tracing and sweep cycles),
	unpredictable stop-the-world lag spikes, non-deterministic (and possibly delayed) memory frees,
	and the complexity of its implementation and tuning (particularly for multi-threaded garbage collection).</li>
	<li><b>pool</b>, used to quickly create sharable allocator references whose size-limited allocated value is freed
	based on the allocator strategy it is built on top of (e.g., manual, rc or gc).
	The primary benefit of pool is a much faster allocation and free of limited-size values than is possible
	with a general-purpose heap allocator. The chief drawbacks are the limits on the size of the object,
	and the runtime bookkeeping costs and lag of its underlying lifetime algorithm.</li>
	</ul>
	<p>Many variations and combinations of the above mechanics are possible, 
	such as rc allocators that use tracing to break cycles,
	multi-threaded garbage collectors that use tracing for intrathread memory management and ref counting
	for inter-thread memory management.</p>
	
	<h2>Custom Allocators</h2>
	<p>New allocators may be created and used. 
	Definition of a new allocator looks and acts very much like a struct with methods.
	For example:</p>
<pre>
// A simple reference counting allocator
alloc rc
  refcnt usize

  fn allocate(size usize) *uni rc
    imm rcref = malloc(size) as *uni rc
    rcref.refcnt = 1
    rcref
  fn alias(self *mutx rc)
    .refcnt += 1
  fn dealias(self *mutx rc)
    .refcnt -= 1
    if .refcnt == 0
      .free()
  fn free(self *mutx rc)
    free(self as *u8)
</pre>
	<p>As this example shows, an allocator typically defines at least these four methods
	which are invoked automatically by the compiler based on key events in the lifetime of an allocator reference:
	<ul>
	<li><b>allocate</b>. This is invoked whenever a new allocator reference is created using the &amp; operator.
	The compiler supplies the sizeof the appropriate type of value to be stored in the allocated memory.
	This size is expanded to include runtime bookkeeping data for the allocator (e.g., refcnt) and permission.
	After allocate, the compiler will also initialize any runtime permission's fields, if needed.
	The compiler's final step is to adjust the pointer to point at the value's data (past the runtime bookkeeping data),
	and then to initialize its value based on the literal, constructor or a copy of another similar value.</li>
	<li><b>alias</b>. This is invoked whenever a new shared copy is made of the reference.</li>
	<li><b>dealias</b>. This is invoked whenever an allocator reference is destroyed, typically when
	the variable holding the reference reaches the end of its lexical lifetime.
	It can also happen when overwriting a reference held by an existing variable or field.</li>
	<li><b>free</b>. This is invoked whenever the allocator determines the value is safe to free.
	Before executing its logic, the compiler will invoke the drop method on the object, if it exist,
	which serves as a finalizer for any resources obtained by the allocator reference.</li>
	</ul>
	<p>Any allocator which does not define the alias method (e.g., the lex allocator)
	ensures single-owner move semantics, as it prevents multiple copies of the reference from being created.
	The single-owner reference is moved instead of being copied.
	This restriction also constrains the permissions on borrowed references,
	effectively disallowing <span class="pre">mut</span> and all other shared mutable permissions.</p>
	<p>Alternatively, an allocator may also define the alias method which performs no logic (e.g., the gc allocator).
	In this case, multiple, sharable references to the same value become possible.</p>
	<p>Notice also that allocators work with pointers (which have no assigned allocator).
	All allocator methods are considered wrapped as trust blocks, which allows the use of pointers
	as well as trusted functions like malloc() and free().
	The pointers are automatically and correctly cast by the compiler back and forth
	from the correct pointer to the correct reference.</p>
	
	<p style="text-align: right; margin-top: 2em;">
		<a href="refperm.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>