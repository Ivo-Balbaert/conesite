<html>
  <head>
	  <title>References and Safety - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">References and Safety</div>
		</div>

    <div class="text">

	<p>The basic idea behind references is pretty simple.
	Instead of having a variable hold a value, we want the variable to hold a reference to some value.
	A reference is effectively an address to the memory location where the value has been stored.
	Using this reference, we can access or change the value the reference points to.</p>
	<p>Let's illustrate this with a simple example.
	The <span class="pre">&</span> operator obtains a reference to a variable,
	and therefore to the value it holds.
	The <span class="pre">*</span> (de-referencing) operator can then be applied to the reference
	to get or change the value pointed to by the reference:</p>
<pre>
mut a = 3
imm ref = &amp;a    // ref holds a reference to a's contents
imm val = *ref  // val is now 3
*ref = 4        // a is now set to 4
</pre>

	<h2>Benefits and Safety Risks</h2>
	<p>References offer important benefits:</p>
	<ul>
		<li><b>Shared access</b>.
			Multiple references can point to the same value,
			such that all of them see and can change the latest value at that address.
			If one reference is used to change a value, another reference to that value sees the updated value.
			By contrast, values passed around between functions do not work this way, as passed values are copies.
			Any change to a copy leaves the original value unchanged.</li>
		<li><b>Space efficiency</b>.
			Some data values can be large, such that making copies of them as they are passed around
			takes up a lot of space and wastes time in the copying.
			In these situations, it can be more efficient to pass around a reference to the large value.</li>
		<li><b>Speed of Vectorization</b>.
			If multiple values are co-located right next to each other in memory,
			it can be faster to use a pointer to process those values sequentially,
			rather than work with each value separately, one at a time.</li>
	</ul>
	
	<p>However, without appropriate constraints, the unfettered ability to
		access and change any arbitrary value based on its address
		opens up a program to significant safety risks:</p>
	<ul>
	<li><b>Memory unsafe</b>. A pointer might point to an object that has been deleted and no longer exists.
	It could also point to an area of memory (e.g., NULL) that has no valid objects.</li>
	<li><b>Concurrency unsafe</b>. One pointer might try to access an object while its
		contents are in the process of being changed by another pointer. Since the contents are
		in transition, they may not make sense to an outside pointer.
		Worse would be when two pointers try to change the same object at the same time across multiple steps,
		making a mess of it in the attempt.</li>
		<li><b>Type unsafe</b>. A pointer might point to an object whose type is different than it expected
	(e.g., the program thought it was pointing at an integer, but there is a float there instead).</li>
	</ul>
	<p>Such failures are not always easy to detect and eliminate when the responsibility for being
		careful lies 100% with fallible humans.
		Although the consequences are not always serious, they <i>could</i> be catastrophic,
	especially when malicious actors take advantage of undetected pointer problems to
	gain access or control over other peoples' privileges or information.</p>
	<p>Because of these safety risks, Cone explicitly distinguishes between references
	  and <a href="refptr.html">pointers</a>.
	  Although both offer addressable access to values,
	  references are constrained to prevent unsafe use.
	  Pointers are not subject to such constraints, making them more versatile but also potentially more dangerous.
	</p>
	
	<h2>Reference Type Signature</h2>
	<p>The way that Cone handles references is unusual among programming languages.
	  Although many capabilities are similar to those found in other languages, Cone's distinctive approach
	  optimizes for versatility, safety and ease-of-use.</p>
	<p>Getting comfortable with Cone's references begins with an introduction to
		the four fundamental mechanisms	that underlie their capabilities and constraints.
	  These mechanisms are formalized as part of the type signature for every reference.</p>
	<ul>
	  <li><a href="refallocref.html"><b>Allocators</b></a>.
		A reference's allocator is responsible for allocating new values.
		The allocator also tracks all allocated values, automatically disposing
		of any values no longer needed.
		Allocators are what makes it possible for a Cone program to support multiple memory strategies,
		such as tracing GC, ref counting, escape-based RAII, arenas, pools, etc.
		In effect, allocators help ensure memory safety.
		A reference that has no allocator is a <a href="refborref.html"><b>borrowed reference</b></a>.</li>
	  <li><a href="refborref.html#lifetime"><b>Lifetimes</b></a>.
		Cone automatically tracks the lifetime of every reference based on its lexical scope.
		Lifetimes are invaluable for ensuring that allocated objects are freed only when no reference
		points to it.
		They also ensure that borrowed references can never point to a freed value.
		In these ways, lifetimes also help improve memory safety.
	  </li>
	  <li><a href="refperm.html"><b>Permissions</b></a>.
		Permissions govern what may be done with a reference.
		Each distinct permission grants and denies certain rights, such as the ability to read
		or change the value the reference points at, or the ability to alias (create a copy of) a reference.
		Permissions also govern the use of atomics, locks and other synchronization mechanisms.
		Permissions help ensure concurrency safety.</li>
	  <li><b>Value type</b>.
		The value type specifies the type of the value that the reference points to.
		References are often treated as simply a stand-in for a value of this type.
		The value type helps protect type safety.</li>
	</ul>
	<p>The following pages provide details on each of these mechanisms.
		For now, it is helpful to know that
	the type signature for a reference always begins with <span class="pre">&</span>
	followed by qualifiers for each of the above mechanisms in the listed order. 
	Here are examples of reference type signatures:</p>
<pre>
imm ref1 &rc imm i32   // ref-counted, immutable reference to an integer value
imm ref2 &i32          // borrowed, 'const' reference to an integer value. Lifetime assumed.
imm ref2 &'a mut i32   // borrowed, 'mut' reference with specified lifetime annotation
</pre>

	<h2>Nullable References</h2>
	<p>By default, references can only point to valid values.
		However, it is possible to explicitly declare and use
		<a href="refnullref.html">nullable references</a>.
		A nullable reference can have the value <span class="pre">null</span>,
		which means the reference does not point to any valid value.</p>
		<p>The type signature for a nullable reference specifies a <span class="pre">?</span>
		after the ampersand:</p>
<pre>
imm ref4 &?i32		    	// borrowed, 'const' nullable reference
</pre>
		
		<p>To ensure safety, access to a nullable reference's value is only possible if
			the code first ensures the reference does not have the value of <span class="pre">null</span>:
		</p>
<pre>
// This condition is true only if maybePoint is not null ...
if (!maybePoint)
		imm point = *maybePoint // ... allowing us to obtain its value
imm point2 = *maybePoint    // **ERROR** We don't know if maybePoint is null here
</pre>
	
	<h2>Reference Operations</h2>
	<p>References are values. As such, they can be stored and passed around a program.
		Whether such transfers are simple copies or moves depends on the reference's type
		(particularly its permission and allocator).
		Reference transfers also check reference type information to ensure everyone is in agreement
		about what you can do with any passed-around reference.</p>
	<p>In general, references are treated as stand-ins for the values they refer to.
		Operations on references will nearly always apply to the value the reference refers to,
		rather than the references themselves.
	  However, there are a few operations which do operate directly on references:
		dereferencing, comparison, and reinterpretation.</p>

	<h3>De-referencing</h3>
	<p>As several examples have demonstrated, the <span class="pre">*</span> operator is used to access a reference's value.
		This is called de-referencing. De-referencing a reference is sometimes prohibited based on
		its permission or whether it might have null as a value.</p>
	<p>For most operations on a reference, a reference is automatically de-referenced before performing the operation.
		For example:</p>
<pre>
// Assume ref1 is a reference to an integer
imm sum = ref1 + 4        // equivalent to *ref1 + 4
</pre>

	<h3>Comparison</h3>
	<p>Two references may be compared for equality, but only if they have the same type signature</p>
<pre>
// Do ref1 and ref2 point to the same value?
if ref1 == ref2
    // do some stuff
</pre>
	<p>It is also possible to compare whether one pointer is greater than another.
		This is typically only meaningful if both refer to somewhere within the same object.</p>

	<h3>Reinterpretation</h3>
	<p>The 'as' operator may be used to take an existing reference and create a new reference
		with a different type signature.
		Whenever this might create some safety risks, use of the 'as' operator will need to happen within a 'trust' blocks.
	</p>
<pre>
imm newref = oldref as &Point  // Coerce a reference to a borrowed reference
</pre>

	<h2>Array and Interface References</h2>
	<p>In addition to the basic references introduced on this page and explored over the next few pages,
		Cone supports more complex reference types that carry more than a pointer.
		These are covered elsewhere:</p>
	<ul>
		<li><a href="refarray.html#arrref"><b>Array references</b></a>,
		which point to a collection of identically-typed elements.
		These elements are contiguous in memory with the reference pointing to the first element.
		The number of elements is carried as part of the array reference.</li>
		<li><a href="refinterface.html"><b>Interface references</b></a>,
		which provide a generic view of some value defined by one of several possible struct types.
		In addition to the object pointer, the reference also points to runtime type information about the value's type,
		such as a vtable for dynamically dispatching method calls on the object.</li>
	</ul>
	<h2 id="match">Partial match</h2>
	<p>Tbd.</p>

		<p style="text-align: right; margin-top: 2em;">
			<a href="refborref.html"><img alt="_" src="next.png" /></a>
		</p>
	
	</div>
	</body>
</html>