<html>
  <head>
	  <title>Blocks - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Blocks and Statements</div>
		</div>

    <div class="text">

		<p>A <a href="refblock.html"><b>block</b></a> is the basic unit for structured control flow.
			It holds a ordered collection of statements that are executed in order, starting with the first statement.
			It may also accumulate its own temporary, local state.</p>
		<p>Blocks offer a versatile, easy-to-apprehend way to structure logic.
	  Their well-defined single point of entry and exit establishes clear
	  boundaries around control flow as well as the local context it manages.
	  Versatility comes from being able to nest different kinds of block easily within each other.
	  This inherent modularity is useful when used in conjunction
	  with control flow statements or to establish a context for compiler operations
		(e.g., safety constraints).</p>
	<p>All of a function's (or closure's) implementation logic is a block.
		Any block may contain other blocks nested within it.</p>
	<p>All blocks support these key roles:</p>
	  <ul>
		<li>Holding an ordered collection of statements</li>
		<li>Establishing a lexical scope for a local context</li>
		<li>Building and/or returning a value</li>
	  </ul>

	<h2>Ordered Collection of Statements</h2>
	<p>At its simplest, a block is merely a ordered set of statements.
	You can tell which statements are part of the same block,
	as they are indented more than the statements that come before and after the block.
	This indentation typically consists of spaces, although tabs are supported if used consistently:</p>
	<p>Let's illustrate this with the most basic kind of block:</p>
<pre>
fn addPlusOne(a i32, b i32) i32:
  ++a
  {
    ++b
	}
  --a
  a + b
</pre>
	<p>The statements incrementing <span class="pre">b</span>
	and decrementing <span class="pre">a</span> comprise an interior block within
	the function's main block. This particular example is a bit contrived,
	as there is no good reason for us to use an interior block here,
	since the function would work the same if those statements were placed in the main block.</p>
<pre>
fn addPlusOne(a i32, b i32) i32 {
  ++a;
  {
    ++b;
	--a;
  }
  a + b;
}
</pre>
	<p>Each statement typically has its own line.
	  However, multiple statements may be placed on the same line, separated with semicolons.
	</p>
		
	<h2 id="blockscope">Lexical Context</h2>
	<p>Execution of a block's statements always begins with the first statement,
	as one cannot jump into the middle of a block. 
	Likewise, execution of the block always finishes at the end of the block.
	This single-entrance and single-exit nature makes it possible for a block
	to create a temporary execution context that persists for the lifetime of the block
	and then is automatically cleaned up at the end of the block.</p>
	
	<h3>Local Variables</h3>
	<p>The block's execution context is created by declaring
		<a href="reffunc.html#local">local</a>, named variables.
		The following example is a bit silly, but it illustrates
		local variables being declared and used in both the function's block
		and the interior block.</p>
<pre>
fn addPlusOne(a i32, b i32) i32:
  mut result = 0;
  {
    mut sum = a + b
  }
  result = sum
  ++result
</pre>
	<p>The block where a variable is defined is considered to be its lexical scope.
	Scopes are nested from outer to inner, with global variables having the outer-most scope.
	Variables declared in outer scopes are accessible in any inner scope.
	However, the reverse is not true.
	Thus, the function's outer block may not refer to <span class="pre">sum</span>.</p>
	<p>If an inner block declares a local variable of the same name
	as an outer scope (including global variables), 
		the outer-scoped variable is effectively inaccessible
		throughout the lexical scope of that inner block.
		To avoid potential confusion, this should be avoided.</p>

	<h3>Resource Disposal</h3>
	<p>The execution lifetime of a local variable does not last beyond its lexical scope.
	At the end of the block, any resources acquired by local variables
	are automatically reclaimed. 
	Reclamation might encompass a wide variety of possible activities,
	including: freeing heap-allocated memory, decrementing counters,
	releasing locks, joining threads,
	or other type-based <a href="refinitdrop.html">finalization</a> activity
	that closes acquired resources or removes dependencies to other objects.
	Once all resources attached to local variables are reclaimed,
	any stack space made available to store the values of these local variables is also reclaimed.</p>
		
	<h2>Returning a block value</h2>
	<p>Blocks are expressions, which mean they can evaluate to a value.
	When a block is used as an expression,
	its value is that of the last statement in the block
	(much like implicit returns for functions):</p>
<pre>
// Using a block as an expression
a = {
    3.14
		6      // a's value will become 6
}
</pre>

		<p style="text-align: right; margin-top: 2em;">
			<a href="refwith.html"><img alt="_" src="next.png" /></a>
		</p>
		
	</div>
	</body>
</html>