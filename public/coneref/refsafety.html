<html>
  <head>
	  <title>Safety Considerations - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Safety Considerations</div>
		</div>

    <div class="text">

	<p>We want programs to be well-behaved,
		doing what we intend without misbehaving in the process.
		Unfortunately, mistakes are both inevitable and costly.
		An obvious cost is the productivity loss due to correcting found mistakes.
		The more significant cost may result from
		security and opportunity risks due to latent bugs.</p>

	<h2>Compile-time Safety</h2>
	<p>To help mitigate these costs, the Cone compiler can detect and prevent these safety violations:</p>
	<ul>
		<li><b>Null pointer exceptions</b>.
			References are not nullable by default.
			When a reference is nullable, it may only be used after runtime logic first ensures it is not null</li>
		<li><b>Uninitialized values</b>.
			It is not legal to access a variable's, field's, or reference's value until it has
			at least been given some valid, initial value.</li>
		<li><b>Out-of-bounds access</b>.
			Array indexing is only permitted when the index lies wholly wihin
			the start and end bounds of the array.</li>
		<li><b>Dangling pointer</b>.
			All references to an object cease to exist before the object is freed.
			Thus, a reference cannot be used-after-free nor can an object be freed twice.</li>
		<li><b>Data races</b>.
			One reference may not access an object while another reference is non-atomically mutating it.</li>
		<li><b>Type violation</b>.
			Every variable, field and reference can only hold values of their declared type.
			Further, if a value can unwrap to one of several variant types,
			runtime logic must first determine which variant it holds before unwrapping it.</li>
	</ul>

	<h2>Safety is the Programmer's Responsibility</h2>
	<p>At the end of the day, the compiler can only act as a valuable assistant,
		skilled at pointing out inconsistencies and obviously-violated constraints.
		It is up to the programmer to write code that protects against:
	<ul>
		<li><b>Memory waste</b>.</li>
		<li><b>Stack and memory overflow</b>.</li>
		<li><b>Deadlocks and other race conditions</b>.</li>
		<li><b>Non-terminating loops</b>.</li>
		<li><b>Broken invariants</b>.</li>
		<li><b>Unanticipated mutation</b>.</li>
		<li><b>Fragile dependencies</b>.</li>
		<li><b>Namespace pollution</b>.</li>
		<li><b>Arithmetic errors</b>.</li>
		<li>and any other kind of bad logic...</li>
	</ul></p>
	<p>To help reduce the likelihood of experiencing the above problems,
		the experienced programmer can leverage helpful language features, such as:
		exception handling, namespace and mutation isolation, bounded iteration,
		private fields on types (to help protect invariants), 
		polymorphism (when inheritance is unnecessary), finalizers, and move semantics.</p>

	<h2>Versatility vs. Safety</h2>
	<p>Although safety matters a lot, we don't want compiler-enforced safety features 
		to negatively impact the productivity of the professional programmer.
		As much as possible, there should be a straightforward way for the programmer
		to write code that their judgement, experience and tests demonstrate is safe.
		Over the next few pages, let's explore several fine-grained controls the programmer
		can use to customize the language's built-in safety constraints.</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="reftrust.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>