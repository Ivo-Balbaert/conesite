<html>
  <head>
	  <title>arrays - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Arrays</div>
		</div>

    <div class="text">

	<p>Array types are for indexed collections of values that have the same type.
    There are many variations of built-in array types, distinguished by how they are declared:</p>
<pre>
imm staticarray [10] f32      // Static array (C-style)
imm arrref      &amp;gc [] f32    // Array reference  
imm slice       &amp;[] f32       // Array slice (borrowed array reference)
imm vecarray    [u32] f32     // Vector variable-sized array struct
imm maparray    [Text] f32    // Map: variable-sized associated array struct
</pre>
    
    <p>Generally, the presence of square brackets in a declaration signals that you are working with
        some kind of indexed collection.
        Similarly, square brackets are used to access one or more elements of an indexed collection.
        Square brackets are also used to define an array literal.
    </p>

    <h2>Array type primitives</h2>
    <p>Let's start with the core language features that make support for array types possible:
        static arrays, array references, and use of pointers as arrays.
    </p>

    <h3>Static arrays</h3>
    <p>The size of a static array is fixed and declared using an unsigned integer literal
        inside square brackets:</p>
<pre>
mut text [4] u32
</pre>
    <p>An array literal creates a static array:</p>
<pre>
mut list = [1f, 4f, 5f]   // [3] f32
</pre>
    <p>An element within a static array is accessed using square brackets:</p>
<pre>
c_array[3] = c_array[2]
</pre>
    <p>Array indexing is automatically bounds-checked by its known size.</p>
    <p>Elements may be accessed using ranges as well:</p>
<pre>
    mut clk = "Abc"
    clk[0..1] = "Ti"          // clk is now "Tic"
</pre>

    <h3>Array References</h3>
    <p>Arrays created while the program is running are represented using array references.
        An array reference (unlike a regular reference) is a 2-value tuple containing:</p>
    <ul>
        <li>a pointer to the first element of the array</li>
        <li>an unsigned integer specifying how many elements are in the array</li>
    </ul>
    <p>An array reference is returned from an array allocation.
        This example allocates an array containing four floating point numbers:</p>
<pre>
imm n = 4
imm newarr = &amp;gc [n] 0.   // newarr's type:  &amp;gc [] f32
</pre>
    <p>Array references may index elements in the same way as for static arrays.
        A run-time check is made to ensure the index is less than the
        size known to the array reference.
    </p>
    <p>Since an array reference is a tuple, its parts can be retrieved
        within a trust block.</p>
<pre>
mut ptr, size = arrref
</pre>

    <h4>Slices</h4>
    <p>A slice is a borrowed array reference.
      A slice is created from an array or another slice using a range within square brackets.
    </p>
<pre>
imm x = &amp;"Abc"[1..3]  // x is a slice pointing to "bc"
imm y = &amp;"Abc"[..]    // y is a slice pointing to "Abc" (0 and end assumed)
</pre>
    <p>A slice is always an alias; a fixed-size view into an array it was created from
        and cannot outlive or re-structure.
      Since slices are always borrowed references, they must conform to lifetime rules.
      Because slices use interior references, they cannot 
      be created from an array that has the shared, mutable permission 'mut',
      as this could lead to potential memory safety problems.
    </p>
    <p><b>Note:</b> If a static array is passed as a parameter, it is automatically
    converted into a slice.</p>

    <h3>Pointers as arrays</h3>
    <p>Any pointer can be treated as if it were a pointer into an array,
        simply by indexing it within a trust block:
    </p>
<pre>
p[3]    // Equivalent to *(p+3)
</pre>
    <p>No boundary checking is performed when indexing a pointer.
        This can be a useful performance boost if the index is already known to be valid.
    </p>
  
    <h2>Struct-based arrays</h2>
    <p>Structs are useful for creating a variable-sized array type.
        Use of a struct makes it possible to offer a useful range of methods
        and then wrap its implementation as private properties.
    </p>
    <p>Square brackets may be used to index into a struct once the '[]' method is implemented:</p>
<pre>
struct VarArray
    _array &amp;gc [] f32

    fn init(size usize)
        _array = &amp;gc [size] f32

    fn `[]`(index usize) f32 trust
        if index &lt; _size       // Should do bounds check
            _array[index]
        else
            0f                 // or panic
</pre>
    <p>This struct acts like an array simply by responding to the <span class="pre">[]</span> method:</p>
<pre>
mut var VarArray
var[3] = var[2]
</pre>

    <p>A slice may be obtained from a struct in the same way as from a fixed-size array,
        again after implementing the '&amp;[]' method:</p>
<pre>
&amp;vararray[..]
</pre>
    <p>This invokes the <span class="pre">&amp;[]</span> method with two arguments.
    That method returns a slice. For example:</p>
<pre>
    fn `&amp;[]`(from usize, to usize) &amp;[] f32 trust
        // .. boundary checking before this
        &amp;_array[from .. to]
</pre>

<h2>Vec: Variable-size arrays</h2>
    <p>Vec is the language standard template for a resizeable array.
    For ease-of-use, the language supports sugar for its use:
<pre>
vec_array [u32] i32   // Equivalent to Vec[i32, u32]
</pre>
    <p>The dimension must be an unsigned integer.</p>
    
    <h2>Map: Variable-size associated arrays</h2>
    <p>Map is the language standard template for a resizeable dictionary map.
    For ease-of-use, the language supports sugar for its use:
<pre>
map_marray [Text] i32  // Equivalent to Map[i32, Text, usize]
</pre>
    <p>The dimension here must be a type that supports the hash method.</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refalloc.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>