<html>
  <head>
	  <title>Arrays - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Arrays</div>
		</div>

    <div class="text">

    <p>What if we want the ability to manipulate several values of the same type,
        all stored together sequentially in memory?
        Cone offers these safe, built-in types to support this capability:
    </p>
    <ul>
        <li><b>Static Array</b> - a fixed-size collection of elements whose size is known at compile-time.</li>
    </ul>

    <h2>Declaration and Creation</h2>
    <p>As a quick glance, these examples show the type signatures for the built-in array types listed above:</p>
<pre>
imm staticarray [10] f32      // Static array
</pre>

    <h3>Static Arrays</h3>
    <p>A static array is a fixed-size collection of elements whose size is known at compile-time.
        It can exist as a global variable or allocated on the stack like any other local variable.
        The type signature for a static array specifies the number of elements as an unsigned integer literal
        inside square brackets, followed by the type of every element:</p>
<pre>
mut text [4] u32
</pre>
    <p>A static array is initialized using an array constructor,
        a comma-separated enumeration of same-typed values enclosed within square brackets:</p>
<pre>
mut list = [1f, 4f, 5f]   // [3] f32
</pre>
    <p>As one would expect, a global variable declaration requires the array constructor
        to contain only literal values. All other uses of the array constructor
        allow the array values to be expressions.</p>
    <p>A static array may also be initialized using a string literal:</p>
<pre>
imm hellotext = "Hello!"  // [6] u8
</pre>


    <h2>Array Operations</h2>
    <p>Arrays may be indexed, copied, compared, iterated over, resized, and queried for their properties.
        These operations work the same way on static arrays, dynamic array, and slices,
        except where otherwise noted.</p>

    <h3>Indexing</h3>
    <p>A <b>single element</b> within an array may be accessed using 
        an unsigned integer value enclosed in square brackets.
        This supports both getting and setting the values at a specific index:</p>
<pre>
c_array[3] = c_array[2]    // the 4th element is now the same as the third
</pre>
    <p>Array indexing is automatically bounds-checked by its known size.
        This technique works with pointers as well, but never performs any bounds-check.
        Using a pointer this way can improve performance where we know the index is safe.
    </p>
    <p>A <b>borrowed reference to a single element</b> can be obtained using the
        ampersand (&amp;) operator:</p>
<pre>
imm borref = &amp;sliceref[4]   // borrow reference to 5th element
</pre>
    <p><b>Multiple elements</b> of an array may be extracted 
        and copied into another array using a range in square brackets.
        Both content segments must have the same type and size.</p>
<pre>
arrref[1 by 2] = sliceref[0 by 2]
greetings[n by 5] = "Kevin"
</pre>
    <p>Similarly, a single value can be repeatedly filled into a slice's elements:</p>
<pre>
arrref[1 .. 3] = 2
</pre>

    <h3>Iteration</h3>
    <p>The <span class="pre">each</span> block provides an easy way to iterate over
    a static array, dynamic array, or slice:</p>
<pre>
mut sum = 0
each x in intslice
    sum += x
</pre>
    <p>Iteration can return a borrowed reference instead of the value:</p>
<pre>
each &mut x in intslice
    ++x
</pre>
    <p>Iteration can also show the index number for each value:</p>
<pre>
each i, x in intslice
    newslice[i] = x
</pre>

    <h3>Comparison</h3>
    <p>Two array references may be compared for equality, so long as they have the same element type,
        even if one is a borrowed reference and the other an allocated reference.
        This comparison checks for equality of both the starting pointer and the element count.</p>
<pre>
if ownref == borref
   ....
</pre>
    <p>Comparing for order (e.g., &lt;) is not possible directly.
        One can of course compare the component parts of an array reference separately (see below).</p>
    <p>Use iteration to compare the contents in two arrays.</p>

    <h3>Property Queries</h3>
    <p>The component parts of an array or array reference can be retrieved separately:</p>
<pre>
imm ptr = array.ptr     // The pointer to the first element
imm len = array.len     // The number of elements
imm count = array.count // The number of elements
imm size = array.size   // The memory size used
</pre>
    <p>Although .count and .len returns the same value for these types,
        this is not necessarily true for other types,
        where .len represents the capacity and .count represents how many elements contain a stored value.
    </p>

    <h2>Structs as indexed collections</h2>
    <p>More complex collections may be created using the built-in array types as a foundation.
        This is typically accomplish by defining a struct with a dynamic array as one of the fields.
        This custom collection can handle all of the operations described earlier
        because these capabilities are invoked as methods on the struct object.
        The struct's methods can then forward these requests down to the dynamic array as appropriate.</p>
    <p>These are the implicit names for these methods:</p>
    <ul>
        <li><b>[]</b> - single-element indexing (get and set) if there is one argument,
            and multi-element indexing if there are two.</li>
        <li><b>&[]</b> - get borrowed reference to a single element</li>
    </ul>
    
    <h2 id="each">each iteration</h2>
    <p>TBD.</p>

	<h2 id="match">Partial match</h2>
	<p>TBD</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refstruct.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>