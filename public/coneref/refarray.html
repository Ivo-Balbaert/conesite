<html>
  <head>
	  <title>arrays - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Arrays</div>
		</div>

    <div class="text">

	<p>Array types are for indexed collections of values that are all the same type.
    There are many variations of built-in array types, distinguished by how they are declared:</p>
<pre>
imm fixarray [10] f32      // Fixed-size array (C-style)
imm slice    &amp;[] f32       // Array slice
imm vecarray [u32] f32     // Vector variable-sized array struct
imm maparray [Text] f32    // Map: variable-sized associated array struct
</pre>
    
    <p>Generally, the presence of square brackets in a declaration signals that you are working with
        some kind of indexed collection.
        Similarly, square brackets are used to access one or more elements of an indexed collection.
        Square brackets are also used to define an array literal.
    </p>

    <h2>Fixed-size arrays</h2>
    <p>Fixed-size arrays declare the size of the array using a constant, unsigned integer literal:</p>
<pre>
mut c_array [4] u32
</pre>
    <p>Array and string literals are fixed-size arrays:</p>
<pre>
mut c_array = "abcd"      // [4] u32
mut list = [1f, 4f, 5f]   // [3] f32
</pre>
    <p>An element may be accessed using square brackets:</p>
<pre>
c_array[3] = c_array[2]
</pre>
    <p>Every attempt to index into such an array is automatically bounds-checked by its known size.</p>

    <h2>Array Slice Borrowed References</h2>
    <p>An array slice is a special kind of borrowed reference.
        Internally, it is represented by a tuple: an interior pointer and a size.
        It is always an alias; a fixed-size view into some sort of array.
    </p>
    <p>A slice is created from an array or another slice using a range within the square brackets.
        (A fixed-size array is automatically turned into a slice when passed as a parameter.)
    </p>
<pre>
imm x = &amp;"Abc"[1..3]  // x is a slice pointing to "bc"
imm y = &amp;"Abc"[..]    // y is a slice pointing to "Abc" (0 and end assumed)
</pre>
    <p>Since slices are always borrowed references, they must conform to lifetime rules.
      Because they involve interior references, they cannot have the shared, mutable permission 'mut'.
    </p>    
  
    <h2>Struct-based arrays</h2>
    <p>Structs are useful for creating a variable-sized arrays.
      Use of a struct is useful way to capture and work with all the array's dependent properties.
      The most straightforward approach is to build around a private pointer property,
      as any pointer may be used as if it pointed to an unbounded array.
      Within a trust block, use of square brackets indexes based on the pointer.
    </p>
<pre>
struct VarArray
    _avail usize  // Capacity
    _size usize
    _ptr *f32

    fn `[]`(index usize) f32 trust
        if index &lt; _size    // Should do bounds check
            _ptr[index]        // Equivalent to: *(ptr+index)
        else
            0f                 // or panic
</pre>
    <p>This struct acts like an array simply by responding to the <span class="pre">[]</span> method:</p>
<pre>
mut var VarArray
var[3] = var[2]
</pre>
    <p>The presence of a pointer in a struct flags the struct as an "interior reference" (?),
        which prohibits the struct from being shared mutable?
        Or should this be a deliberate trait flagged?
        Or should we use reference for a non-interior object reference and copy to pointer when used?
    </p>
    <p>TBD: constructor is required. How to implement using allocators?</p>

    <h3>Slices from struct</h3>
    <p>A slice may be obtained from a struct in the same way as from a fixed-size array:</p>
<pre>
&amp;vararray[..]
</pre>
    <p>This invokes the <span class="pre">[]</span> method with two arguments.
    That method returns a slice. For example:</p>
<pre>
    fn `[]`(from usize, to usize) &amp;[] f32 trust
        // .. boundary checking before this
        &amp;_ptr[from .. to]
</pre>

<h2>Vec: Variable-size arrays</h2>
    <p>Vec is the language standard template for a resizeable array.
    For ease-of-use, the language supports sugar for its use:
<pre>
vec_array [u32] i32   // Equivalent to Vec[i32, u32]
</pre>
    <p>The dimension must be an unsigned integer.</p>
    
    <h2>Map: Variable-size associated arrays</h2>
    <p>Map is the language standard template for a resizeable dictionary map.
    For ease-of-use, the language supports sugar for its use:
<pre>
map_marray [Text] i32  // Equivalent to Map[i32, Text, usize]
</pre>
    <p>The dimension here must be a type that supports the hash method.</p>

	<p style="text-align: right; margin-top: 2em;">
		<a href="refalloc.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>