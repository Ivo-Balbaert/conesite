<html>
  <head>
	  <title>unions - Cone Reference</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">unions</div>
		</div>

    <div class="text">
		<p style="margin-left: 40px;"><i>Note: None of this capability is currently implemented.</i></p>

		<p>Like enums, unions allow a value's type structure to vary.
			Unions permit greater data structure flexibility than enums,
			because they make the nature of the tag more explicit.</p>
			<p>The safe way to use a union is within a struct,
			where the union points to the explicit tag field in the struct:</p>
<pre>
struct Event
  evtype u32
  time Time
  union : evtype
    MouseButton
      button u8
      x i32
      y i32
    Keyboard
      keysym KeySym
		Quit
</pre>
		<p>The <span class="pre">Event</span> type encodes user-initiated events,
			such as clicking a mouse button, pressing a key on the keyboard, or quitting the program.
			These are variant types of events, that all share some fields in common, such as
			<span class="pre">time</span>'s timestamp info.
			Each event type also defines its own specific fields.
			Notice that union points to the common <span class="pre">evtype</span> field,
			making it the type's tag field used to determine which variant type a value holds.</p>
	
	<h3>Declaration</h3>
	<p>The union's declaration looks largely identical to that of an enum.
		An important difference is that a union needs to specify which of the enclosing struct's fields
		is to be used as the discriminating tag.</p>

		<h3>Initialization</h3>
		<p>A union-based struct value is built using a variation of the struct constructor:</p>
<pre>
mut event = Event::MouseButton[now, button: 0, x: 140, y: 170]
event = Event::Keyboard[now, 'a']
event = Event::Quit[now]
</pre>
		<p>How this differs from a normal struct constructor should be pretty obvious:
			instead of giving the tag's value inside the constructor, we qualify the type's
			name with the type of the variant.</p>

		<h3>Copying</h3>
		<p>A struct value with an embedded union may be passed around, by copy, just like any other value.
			As with enums, all variant values of a union-based struct type are the same size.
		</p>

		<h3>Value Access</h3>
		<p>Any field in common across all variants may be accessed in the same way as any normal field:</p>
<pre>
imm when = event.time
</pre>
		<p>However, much like enum, to safely gain access to any of the union-declared variant fields,
			we must use <a href="refmatch.html">pattern matching</a>:</p>
<pre>
match event
  ~~ mbutton = MouseButton:   mbutton.x
  ~~ key = Keyboard:          i32[key.keysym]
  ~~ Quit:                    0
</pre>

		<h3>Comparing</h3>
		<p>Just like with vanilla structs,
				two union-based struct values may be only compared if the struct implements
				the <a href="refmethod.html#compare">comparison methods</a>.
			</p>
		
	<p style="text-align: right; margin-top: 2em;">
		<a href="refmethod.html"><img alt="_" src="next.png" /></a>
	</p>

	</div>
	</body>
</html>