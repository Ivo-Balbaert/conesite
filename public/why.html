<html>
  <head>
	  <title>Cone Introduction</title>
		<meta content="text/html; charset=UTF-8" http-equiv="content-type">
		<meta name="viewport" content="width=device-width, initial-scale=1" />
	  <link rel="stylesheet" type="text/css" href="standard.css" />
	</head>
  <body>
		<div id="header">
			<a href="/"><div id="title">Cone</div></a>
			<div id="sub">Introduction</div>
		</div>

    <div class="text">
		<p>Cone is a fast, fit, friendly, and safe systems programming language:</p>
		<ul>
			<li><b>Fast</b>. Systems programming languages (like C) produce the fastest programs.
			Cone is no exception.</li>
			<li><b>Fit</b>. Cone programs pack a lot of power for their size,
				both as source files and as delivered executables.</li>
			<li><b>Friendly</b>. The language design makes programs easy to read and change.
			  The tools accelerate your time-to-market.</li>
			<li><b>Safe</b>. Built-in mechanisms ensure programs behave well,
				even when dealing with raw memory or concurrency.</li>
		</ul>
		<p>These words are accurate, but they don't helpfully communicate
		the distinctive features that make Cone worth learning and using.</p>
		
		<h2>Fast</h2>
		<p>Certain kinds of programs require optimal performance,
		as they must crunch large volumes of data within punishing responsiveness requirements:
		web servers handling high-volume searches with sub-second response times, 
		logistics or AI software controlling devices in real-time,
		photo-realistic 3D gaming worlds, and more...</p>
		<p>Systems programming languages (like C) are known to produce the fastest programs.
		Cone is no exception, generating highly-optimized native executables
		that process the kind of data that CPUs handle most efficiently.
		Where performance matters, this approach is necessary but not sufficient.
		Cone's design goes deeper...</p>
		<p>Programs that manage memory efficiently run rings around those that don't. 
		Lots of precious cycles can be wasted allocating, freeing, copying, 
		and liveness tracking millions of small data objects.
		Additional cycles are wasted accessing these objects out of order,
		oblivious to the significant performance benefits of cache-friendy access.</p>
		<p>To minimize these cycle wasters, Cone offers a versatile range of
		easy-to-use (and safe) memory and array management strategies.
		First-class arenas and pools reduce memory allocation and free costs.
		Single-owner resources and borrowed references improve determinism
		and lower garbage collection bookkeeping costs.
		Array primitives facilitate cache-friendly, data-oriented design patterns.
		Lastly, data structures requiring complex flexibility can leverage
		low-latency tracing and ref-counted garbage collection.
		<p>Concurrency offers another vector for performance gains.
		Cone makes it easy for programs to leverage the power of multi-CPU computer devices.
		Work can be easily divided into independent, concurrent threads.
		The greatest performance gains from concurrency come from minimizing
		the use of locks/synchronization that protect against race conditions. 
		Cone's versatile permissions support the safe, lockless exchange of
		immutable and mutable data between threads.
		This improves the likelihood that threads will operate at full capacity.</p>
		

		<h2>Design Goals</h2>
		<p>The <b><a href="/web3d">3D web</a></b> is the "killer app" focus for Cone.
		As a result, it must handle these programming language roles well:</p>
		<ul>
		<li><b>simulation modelling</b>, enabling specification of complex systems
		that can be simulated via real-time high-quality rendering, 
		timely interactions between people and parts, and rule-driven changes of state.</li>
		<li><b>event-driven control flow</b>, so worlds stay calm and responsive 
		while juggling a blur of competing workload demands.</li>
		<li><b>object- and actor-oriented modularity</b>, as snapping together flexibly typed, modular parts,
		each with its own content and behavior, is ideally suited to the object-oriented paradigm.</li>
		<li><b>static typing</b>, to accelerate performance and ensure compile-time
		memory, concurrence and type safety.</li>
		</ul>
			
		<p>In pursuit of its core focus, Cone supports:</p>
		<ul>
			<li><a href="/memory.html">"Do-it-your-way" memory management</a></li>
			<li><a href="/reuse.html">Flexible typing & code reuse</a></li>
			<li><a href="/concise.html">Concise, readable code</a></li>
			<li><a href="/safety.html">Memory, thread & type safety</a></li>
			<li><a href="/runtime.html">Lean, native runtime</a></li>
		</ul>
		<p>It turns out that Cone's ability to handle the punishing demands required for realtime, realistic 3D
			means it also has the fitness and ease-of-use to handle other, less-demanding program requirements.</p>

		<h2>What's Special about Cone?</h2>
		<p>There are many programming languages to choose from. 
			What makes Cone worth taking the time to get to know it better?
		Let's start with a few distinctive features you won't find in any comparable language:</p>
		<ul>
			<li><b><a href="refrefs.html">References</a></b>.
				You've never seen references safely carry this much power and flexibility.
			With them, a program can easily exploit the broadest range of multiple
			<a href="refalloc.html">memory management strategies</a>
			(from fast RAII to flexible GC) in a way that optimizes performance and productivity.
			Furthermore, references support the fluid transition of any value's 
			<a href="refperm.html">access permissions</a> as it flows
			through a program, making possible faster approaches to safe, lockless concurrency.</li>
			<li><b><a href="">Extensible Pattern Matching</a></b>.
				You can build your own pattern matchers
				which not only determine if there is a successful match, 
				but can also extract values as part of the process.</li>
			<li><b><a href="">Structural Traits</a></b>.
				Like other languages, Cone supports nominal traits
				which a struct may declare that it implements.
				Unusually, Cone <i>also</i> supports structural traits, which allow types
				to be more flexibly applied to generic program logic even in the absence of a declared implementation.</li>
			<li><b><a href="">With blocks</a></b>.
				This simple bit of syntactic sugar goes a long way towards improving code clarity,
				particularly when working with complex content (e.g., a 3D world).
				This lexical structure makes it easier to see what content the code is working on and
				what it is doing with that content.
			</li>
		</ul>
		<p>Of course, Cone also supports features expected of a modern programming language:</p>
		<ul>
			<li>Variant (sum) types</li>
			<li>Closures and anonymous functions</li>
			<li>Concurrency</li>
			<li>Generics and metaprogramming</li>
			<li>Tuples, for parallel assignment and multiple return values</li>
			<li>Slices and built-in iteration</li>
			<li>Operator overloading and computable properties</li>
		</ul>

		<h2>Additional material</h2>
		<p>There are several approaches one can take to learn more about Cone:</p>

		<ul>
		<li><b><a href="/play/index.html">Cone Playground</a></b>.
			Offers helpful short sample programs which can be modified and run in the browser.</li>
		<li><b><a href="showcase.html">Showcase</a></b>.
		A few selected examples that demonstrate Cone's visual style and idioms.</li>
		<li><b><a href="refterm.html">Language Reference</a></b>.
		Progressive and comprehensive descriptions (with examples) of Cone's features.</li>
		<li><b><a href="diagram.xhtml">Syntax</a></b>.
		Formal grammar using railroad diagrams and EBNF notation.</li>
		</ul>
		
		<p style="text-align: right; margin-top: 2em;">
			<a href="showcase.html"><img alt="_" src="next.png" /></a>
		</p>
	</div>
	</body>
</html>